Index: app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.ui.activities;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.view.Menu;\r\nimport android.view.MenuItem;\r\nimport android.widget.Button;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.appcompat.app.AlertDialog;\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.appcompat.widget.Toolbar;\r\nimport androidx.lifecycle.ViewModelProvider;\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.bumptech.glide.Glide;\r\nimport com.example.cooking.Recipe.Ingredient;\r\nimport com.example.cooking.Recipe.Step;\r\nimport com.example.cooking.R;\r\nimport com.example.cooking.Recipe.Recipe;\r\nimport com.example.cooking.ui.adapters.StepAdapter;\r\nimport com.example.cooking.ui.adapters.IngredientViewAdapter;\r\nimport com.example.cooking.ui.viewmodels.RecipeDetailViewModel;\r\nimport com.google.android.material.floatingactionbutton.FloatingActionButton;\r\nimport com.google.android.material.imageview.ShapeableImageView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\n/**\r\n * Активность для отображения подробной информации о рецепте.\r\n * Показывает полное описание, ингредиенты и инструкцию.\r\n */\r\npublic class RecipeDetailActivity extends AppCompatActivity {\r\n    // Константы для передачи данных между активностями\r\n    public static final String EXTRA_RECIPE_TITLE = \"recipe_title\";\r\n    public static final String EXTRA_RECIPE_CREATOR = \"recipe_creator\";\r\n    public static final String EXTRA_RECIPE_INSTRUCTOR = \"recipe_instructor\";\r\n    public static final String EXTRA_RECIPE_FOOD = \"recipe_food\";\r\n    public static final String EXTRA_RECIPE_PHOTO_URL = \"photo_url\";\r\n    public static final String EXTRA_SELECTED_RECIPE = \"SELECTED_RECIPE\"; // <-- Ключ для Parcelable\r\n    private static final String TAG = \"RecipeDetailActivity\";\r\n    private static final int EDIT_RECIPE_REQUEST = 1001;\r\n    \r\n    // UI-компоненты\r\n    private FloatingActionButton fabLike;\r\n    private TextView titleTextView;\r\n    private ShapeableImageView recipeImageView;\r\n    private TextView createdAtTextView;\r\n    private Button decreasePortionButton;\r\n    private Button increasePortionButton;\r\n    private TextView portionCountTextView;\r\n    private Button toListButton;\r\n    private Button toCartButton;\r\n    private RecyclerView stepsRecyclerView;\r\n    private StepAdapter stepAdapter;\r\n    private RecyclerView ingredientsRecyclerView;\r\n    private IngredientViewAdapter ingredientAdapter;\r\n    \r\n    // Данные рецепта\r\n    private Recipe currentRecipe; // Будем хранить весь объект\r\n    private int recipeId;\r\n    private String userId;\r\n    private int currentPortionCount = 1;\r\n    private List<Step> steps = new ArrayList<>();\r\n    private List<Ingredient> ingredients = new ArrayList<>();\r\n    \r\n    // ViewModel\r\n    private RecipeDetailViewModel viewModel;\r\n    \r\n    /**\r\n     * Инициализирует активность и заполняет её данными о рецепте\r\n     */\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_recipe_detail);\r\n\r\n        // Настраиваем toolbar\r\n        Toolbar toolbar = findViewById(R.id.toolbar);\r\n        setSupportActionBar(toolbar);\r\n        \r\n        // Настраиваем обработчик нажатия на кнопку \"назад\"\r\n        toolbar.setNavigationOnClickListener(v -> finish());\r\n\r\n        // Получаем данные о рецепте из Intent\r\n        currentRecipe = getIntent().getParcelableExtra(EXTRA_SELECTED_RECIPE); // Используем константу\r\n\r\n        // Проверяем, что данные получены\r\n        if (currentRecipe == null) {\r\n            Log.e(TAG, \"Объект Recipe не найден в Intent extras. Ключ: \" + EXTRA_SELECTED_RECIPE);\r\n            Toast.makeText(this, \"Ошибка: Не удалось загрузить данные рецепта.\", Toast.LENGTH_LONG).show();\r\n            finish(); // Закрываем активность, если данных нет\r\n            return;\r\n        }\r\n\r\n        // Извлекаем данные из объекта Recipe\r\n        recipeId = currentRecipe.getId();\r\n        userId = currentRecipe.getUserId();\r\n        // Списки берем напрямую из объекта\r\n        this.ingredients = currentRecipe.getIngredients() != null ? new ArrayList<>(currentRecipe.getIngredients()) : new ArrayList<>();\r\n        this.steps = currentRecipe.getSteps() != null ? new ArrayList<>(currentRecipe.getSteps()) : new ArrayList<>();\r\n\r\n        // Логируем полученные данные для отладки\r\n        Log.d(TAG, \"Получен рецепт: ID = \" + recipeId + \", Название = \" + currentRecipe.getTitle());\r\n        Log.d(TAG, \"Кол-во ингредиентов: \" + this.ingredients.size());\r\n        Log.d(TAG, \"Кол-во шагов: \" + this.steps.size());\r\n        Log.d(TAG, \"Дата создания: \" + currentRecipe.getCreated_at());\r\n        Log.d(TAG, \"ID пользователя: \" + userId);\r\n        Log.d(TAG, \"URL фото: \" + currentRecipe.getPhoto_url());\r\n        Log.d(TAG, \"Лайкнут: \" + currentRecipe.isLiked());\r\n        \r\n        // Инициализируем UI-компоненты\r\n        titleTextView = findViewById(R.id.recipe_title);\r\n        recipeImageView = findViewById(R.id.recipe_image);\r\n        createdAtTextView = findViewById(R.id.recipe_date);\r\n        fabLike = findViewById(R.id.like_button);\r\n        decreasePortionButton = findViewById(R.id.decrease_portion);\r\n        increasePortionButton = findViewById(R.id.increase_portion);\r\n        portionCountTextView = findViewById(R.id.portion_count);\r\n        stepsRecyclerView = findViewById(R.id.steps_recyclerview);\r\n        ingredientsRecyclerView = findViewById(R.id.ingredients_recyclerview);\r\n        \r\n        // Настраиваем RecyclerView для шагов\r\n        setupStepsRecyclerView();\r\n        \r\n        // Настраиваем RecyclerView для ингредиентов\r\n        setupIngredientsRecyclerView();\r\n\r\n        // Инициализируем и настраиваем ViewModel\r\n        viewModel = new ViewModelProvider(this).get(RecipeDetailViewModel.class);\r\n        // Вместо передачи всех полей, передаем только ID\r\n        // ViewModel должен сам загрузить Recipe из репозитория по ID\r\n        viewModel.loadRecipe(recipeId); \r\n        \r\n        // Настраиваем наблюдателей LiveData\r\n        setupObservers();\r\n        \r\n        // Настраиваем обработчики событий\r\n        setupEventListeners();\r\n\r\n        // Первичное отображение данных из Intent (пока ViewModel загружает)\r\n        Log.d(TAG, \"onCreate: Установка начального UI...\");\r\n        if (titleTextView != null && currentRecipe != null) {\r\n            Log.d(TAG, \"onCreate: Установка заголовка: \" + currentRecipe.getTitle());\r\n            titleTextView.setText(currentRecipe.getTitle());\r\n        } else {\r\n            Log.e(TAG, \"onCreate: titleTextView is null или currentRecipe is null перед установкой заголовка\");\r\n        }\r\n        createdAtTextView.setText(String.format(Locale.getDefault(), \"Создано: %s\", currentRecipe.getCreated_at()));\r\n        updateLikeButton(currentRecipe.isLiked());\r\n        if (recipeImageView != null && currentRecipe != null && currentRecipe.getPhoto_url() != null && !currentRecipe.getPhoto_url().isEmpty()) {\r\n            Log.d(TAG, \"onCreate: Загрузка изображения Glide: \" + currentRecipe.getPhoto_url());\r\n            Glide.with(this)\r\n                 .load(currentRecipe.getPhoto_url())\r\n                 .placeholder(R.drawable.placeholder_image)\r\n                 .error(R.drawable.error_image)\r\n                 .into(recipeImageView);\r\n        } else {\r\n            Log.w(TAG, \"onCreate: Не удалось загрузить изображение Glide (ImageView null, Recipe null, URL null/пустой)\");\r\n             if(recipeImageView != null) recipeImageView.setImageResource(R.drawable.default_recipe_image); // Установим дефолтное изображение\r\n        }\r\n        updatePortionCount();\r\n    }\r\n    \r\n    /**\r\n     * Настраивает RecyclerView для шагов рецепта\r\n     */\r\n    private void setupStepsRecyclerView() {\r\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this);\r\n        stepsRecyclerView.setLayoutManager(layoutManager);\r\n        // Создаем адаптер\r\n        stepAdapter = new StepAdapter(this); \r\n        stepsRecyclerView.setAdapter(stepAdapter);\r\n        // Сразу передаем шаги, полученные из Intent\r\n        stepAdapter.submitList(this.steps); \r\n        Log.d(TAG, \"setupStepsRecyclerView: Передано шагов в адаптер: \" + this.steps.size()); // Добавим лог\r\n    }\r\n    \r\n    /**\r\n     * Настраивает RecyclerView для ингредиентов\r\n     */\r\n    private void setupIngredientsRecyclerView() {\r\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this);\r\n        ingredientsRecyclerView.setLayoutManager(layoutManager);\r\n        // Инициализируем адаптер списком, полученным из Parcelable\r\n        ingredientAdapter = new IngredientViewAdapter(this, this.ingredients);\r\n        ingredientsRecyclerView.setAdapter(ingredientAdapter);\r\n    }\r\n    \r\n    /**\r\n     * Настраивает обработчики событий\r\n     */\r\n    private void setupEventListeners() {\r\n        // Настраиваем клик по кнопке \"лайк\"\r\n        fabLike.setOnClickListener(v -> viewModel.toggleLike());\r\n        \r\n        // Настраиваем кнопки изменения порции\r\n        decreasePortionButton.setOnClickListener(v -> {\r\n            if (currentPortionCount > 1) {\r\n                currentPortionCount--;\r\n                updatePortionCount();\r\n            }\r\n        });\r\n        \r\n        increasePortionButton.setOnClickListener(v -> {\r\n            currentPortionCount++;\r\n            updatePortionCount();\r\n        });\r\n            }\r\n    \r\n    /**\r\n     * Обновляет отображение количества порций\r\n     */\r\n    private void updatePortionCount() {\r\n        portionCountTextView.setText(String.valueOf(currentPortionCount));\r\n        // Убедимся, что адаптер не null перед вызовом\r\n        if (ingredientAdapter != null) { \r\n            ingredientAdapter.updatePortionCount(currentPortionCount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Настраивает наблюдение за данными из ViewModel\r\n     */\r\n    private void setupObservers() {\r\n        // Наблюдаем за данными рецепта из ViewModel\r\n        viewModel.getRecipe().observe(this, recipeFromVm -> {\r\n            if (recipeFromVm != null) {\r\n                Log.d(TAG, \"Получен обновленный рецепт из ViewModel. Шагов: \" + (recipeFromVm.getSteps() != null ? recipeFromVm.getSteps().size() : \"null\"));\r\n                currentRecipe = recipeFromVm; // Обновляем текущий рецепт\r\n                updateUI(currentRecipe); // Обновляем весь UI свежими данными\r\n            } else {\r\n                Log.w(TAG, \"ViewModel вернул null Recipe объект.\");\r\n                // Можно показать сообщение об ошибке или использовать данные из Intent\r\n                // если они были успешно получены ранее\r\n                if (currentRecipe != null) { \r\n                    updateUI(currentRecipe); // Показываем то, что пришло в Intent\r\n                } else {\r\n                     Toast.makeText(this, \"Не удалось загрузить детали рецепта.\", Toast.LENGTH_SHORT).show();\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Наблюдаем за состоянием лайка\r\n        viewModel.isLiked().observe(this, this::updateLikeButton);\r\n        \r\n        // Наблюдаем за сообщениями об ошибках\r\n        viewModel.getErrorMessage().observe(this, error -> {\r\n            if (error != null && !error.isEmpty()) {\r\n                Toast.makeText(this, error, Toast.LENGTH_LONG).show();\r\n            }\r\n        });\r\n        \r\n        // Наблюдаем за статусом удаления\r\n        viewModel.isDeleteSuccess().observe(this, isSuccess -> {\r\n            if (isSuccess) {\r\n                Toast.makeText(this, \"Рецепт успешно удален\", Toast.LENGTH_SHORT).show();\r\n                setResult(RESULT_OK);\r\n                finish();\r\n            }\r\n        });\r\n        \r\n        // Наблюдаем за разрешением на редактирование\r\n        viewModel.hasEditPermission().observe(this, hasPermission -> {\r\n            invalidateOptionsMenu(); // Обновляем меню\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Обновляет UI элементы данными из рецепта (полученного из ViewModel)\r\n     */\r\n    private void updateUI(Recipe recipe) {\r\n        if (recipe == null) {\r\n            Log.w(TAG, \"updateUI вызван с null Recipe объектом.\");\r\n            return;\r\n        }\r\n        Log.d(TAG, \"updateUI: Обновление UI для рецепта: \" + recipe.getTitle());\r\n        \r\n        if (titleTextView != null) {\r\n             Log.d(TAG, \"updateUI: Установка заголовка: \" + recipe.getTitle());\r\n            titleTextView.setText(recipe.getTitle());\r\n        } else {\r\n             Log.e(TAG, \"updateUI: titleTextView is null\");\r\n        }\r\n        createdAtTextView.setText(String.format(Locale.getDefault(), \"Создано: %s\", recipe.getCreated_at()));\r\n        updateLikeButton(recipe.isLiked());\r\n\r\n        // Обновляем адаптеры новыми данными\r\n        this.ingredients = recipe.getIngredients() != null ? new ArrayList<>(recipe.getIngredients()) : new ArrayList<>();\r\n        if (ingredientAdapter != null) {\r\n            ingredientAdapter.updateIngredients(this.ingredients);\r\n            ingredientAdapter.updatePortionCount(currentPortionCount); \r\n        } else {\r\n             Log.e(TAG, \"updateUI: ingredientAdapter is null\");\r\n        }\r\n        \r\n        this.steps = recipe.getSteps() != null ? new ArrayList<>(recipe.getSteps()) : new ArrayList<>();\r\n        if (stepAdapter != null) {\r\n             stepAdapter.submitList(this.steps);\r\n        } else {\r\n             Log.e(TAG, \"updateUI: stepAdapter is null\");\r\n        }\r\n\r\n        if (recipeImageView != null && recipe.getPhoto_url() != null && !recipe.getPhoto_url().isEmpty()) {\r\n             Log.d(TAG, \"updateUI: Загрузка изображения Glide: \" + recipe.getPhoto_url());\r\n             Glide.with(this)\r\n                  .load(recipe.getPhoto_url())\r\n                  .placeholder(R.drawable.placeholder_image)\r\n                  .error(R.drawable.error_image)\r\n                  .into(recipeImageView);\r\n        } else {\r\n             Log.w(TAG, \"updateUI: Не удалось загрузить изображение Glide (ImageView null, URL null/пустой)\");\r\n             if(recipeImageView != null) recipeImageView.setImageResource(R.drawable.default_recipe_image); // Установим дефолтное изображение\r\n        }\r\n        invalidateOptionsMenu(); \r\n    }\r\n    \r\n    /**\r\n     * Обновляет состояние кнопки лайка\r\n     */\r\n    private void updateLikeButton(boolean isLiked) {\r\n        if (isLiked) {\r\n            fabLike.setImageResource(R.drawable.ic_favorite); // Закрашенный лайк\r\n        } else {\r\n            fabLike.setImageResource(R.drawable.ic_favorite_border); // Пустой лайк\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    public boolean onCreateOptionsMenu(Menu menu) {\r\n        getMenuInflater().inflate(R.menu.menu_recipe_detail, menu);\r\n        MenuItem editItem = menu.findItem(R.id.action_edit);\r\n        MenuItem deleteItem = menu.findItem(R.id.action_delete);\r\n\r\n        // Показываем или скрываем кнопки в зависимости от разрешений\r\n        Boolean hasPermission = viewModel.hasEditPermission().getValue();\r\n        if (editItem != null) editItem.setVisible(hasPermission != null && hasPermission);\r\n        if (deleteItem != null) deleteItem.setVisible(hasPermission != null && hasPermission);\r\n\r\n        return true;\r\n    }\r\n    \r\n    @Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n        Recipe recipe = viewModel.getRecipe().getValue();\r\n        if (recipe == null) {\r\n            return super.onOptionsItemSelected(item);\r\n        }\r\n        \r\n        int itemId = item.getItemId();\r\n        \r\n        if (itemId == R.id.action_share) {\r\n            shareRecipe(recipe);\r\n            return true;\r\n        } else if (itemId == R.id.action_edit) {\r\n            editRecipe(recipe);\r\n            return true;\r\n        } else if (itemId == R.id.action_delete) {\r\n            showDeleteConfirmationDialog();\r\n            return true;\r\n        }\r\n        \r\n        return super.onOptionsItemSelected(item);\r\n    }\r\n    \r\n    /**\r\n     * Показывает диалог подтверждения удаления рецепта\r\n     */\r\n    private void showDeleteConfirmationDialog() {\r\n        new AlertDialog.Builder(this)\r\n                .setTitle(\"Удалить рецепт?\")\r\n                .setMessage(\"Вы уверены, что хотите удалить этот рецепт? Это действие необратимо.\")\r\n                .setPositiveButton(\"Удалить\", (dialog, which) -> {\r\n                    Recipe recipe = viewModel.getRecipe().getValue();\r\n                    if (recipe != null) {\r\n                        viewModel.deleteRecipe(recipe.getId());\r\n                    } else {\r\n                        Toast.makeText(this, \"Ошибка: Не удалось получить ID рецепта для удаления.\", Toast.LENGTH_SHORT).show();\r\n                    }\r\n                })\r\n                .setNegativeButton(\"Отмена\", null)\r\n                .show();\r\n    }\r\n    \r\n    /**\r\n     * Делится рецептом через другие приложения\r\n     */\r\n    private void shareRecipe(Recipe recipe) {\r\n        if (recipe == null) return;\r\n\r\n        Intent shareIntent = new Intent(Intent.ACTION_SEND);\r\n        shareIntent.setType(\"text/plain\");\r\n        String shareBody = \"Посмотри рецепт: \" + recipe.getTitle() + \"\\nПодробнее: [ссылка на приложение или веб-версию]\"; // TODO: Добавить ссылку\r\n        shareIntent.putExtra(Intent.EXTRA_SUBJECT, \"Рецепт: \" + recipe.getTitle());\r\n        shareIntent.putExtra(Intent.EXTRA_TEXT, shareBody);\r\n\r\n        startActivity(Intent.createChooser(shareIntent, \"Поделиться рецептом через\"));\r\n    }\r\n    \r\n    /**\r\n     * Открывает активность редактирования рецепта\r\n     */\r\n    private void editRecipe(Recipe recipe) {\r\n        if (recipe == null) return;\r\n        Intent intent = new Intent(this, EditRecipeActivity.class);\r\n        intent.putExtra(EditRecipeActivity.EXTRA_EDIT_RECIPE, recipe);\r\n        startActivityForResult(intent, EDIT_RECIPE_REQUEST);\r\n    }\r\n    \r\n    @Override\r\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n        super.onActivityResult(requestCode, resultCode, data);\r\n        \r\n        if (requestCode == EDIT_RECIPE_REQUEST && resultCode == RESULT_OK) {\r\n            // Рецепт был изменен, нужно перезагрузить данные\r\n            Toast.makeText(this, \"Рецепт обновлен\", Toast.LENGTH_SHORT).show();\r\n            if (viewModel != null) {\r\n                viewModel.loadRecipe(recipeId); // Заставляем ViewModel перезагрузить данные\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java b/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java
--- a/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java	(revision 13d31353b547022b462dac88d1070f6fc5bae46e)
+++ b/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java	(date 1745091363537)
@@ -262,6 +262,8 @@
                 Toast.makeText(this, "Рецепт успешно удален", Toast.LENGTH_SHORT).show();
                 setResult(RESULT_OK);
                 finish();
+
+
             }
         });
         
Index: app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.ui.viewmodels;\r\n\r\nimport android.app.Application;\r\nimport android.util.Log;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.lifecycle.AndroidViewModel;\r\nimport androidx.lifecycle.LiveData;\r\nimport androidx.lifecycle.MutableLiveData;\r\n\r\nimport com.example.cooking.Recipe.Recipe;\r\nimport com.example.cooking.data.database.RecipeEntity;\r\nimport com.example.cooking.data.repositories.RecipeRepository;\r\nimport com.example.cooking.network.services.RecipeDeleter;\r\nimport com.example.cooking.utils.MySharedPreferences;\r\nimport com.example.cooking.data.repositories.RecipeLocalRepository;\r\n\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\nimport okhttp3.Call;\r\nimport okhttp3.Callback;\r\nimport okhttp3.MediaType;\r\nimport okhttp3.OkHttpClient;\r\nimport okhttp3.Request;\r\nimport okhttp3.RequestBody;\r\nimport okhttp3.Response;\r\n\r\n/**\r\n * ViewModel для RecipeDetailActivity\r\n * Управляет данными и логикой экрана детального просмотра рецепта\r\n */\r\npublic class RecipeDetailViewModel extends AndroidViewModel {\r\n\r\n    private static final String TAG = \"RecipeDetailViewModel\";\r\n    private static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");\r\n\r\n    private final OkHttpClient client;\r\n    private final ExecutorService executor;\r\n    private final RecipeDeleter recipeDeleter;\r\n    private final RecipeLocalRepository localRepository;\r\n    private final RecipeRepository recipeRepository;\r\n    private final MySharedPreferences preferences;\r\n\r\n    // LiveData для хранения состояний\r\n    private final MutableLiveData<Recipe> recipe = new MutableLiveData<>();\r\n    private final MutableLiveData<Boolean> isLiked = new MutableLiveData<>(false);\r\n    private final MutableLiveData<Boolean> isDeleting = new MutableLiveData<>(false);\r\n    private final MutableLiveData<Boolean> deleteSuccess = new MutableLiveData<>(false);\r\n    private final MutableLiveData<String> errorMessage = new MutableLiveData<>();\r\n    private final MutableLiveData<Boolean> hasEditPermission = new MutableLiveData<>(false);\r\n\r\n    public RecipeDetailViewModel(@NonNull Application application) {\r\n        super(application);\r\n        client = new OkHttpClient();\r\n        executor = Executors.newSingleThreadExecutor();\r\n        recipeDeleter = new RecipeDeleter(application);\r\n        localRepository = new RecipeLocalRepository(application);\r\n        recipeRepository = new RecipeRepository(application);\r\n        preferences = new MySharedPreferences(application);\r\n    }\r\n\r\n    /**\r\n     * Загружает данные рецепта по ID из кэша репозитория.\r\n     * @param recipeId ID рецепта для загрузки.\r\n     */\r\n    public void loadRecipe(int recipeId) {\r\n        if (recipeId == -1) {\r\n            errorMessage.postValue(\"Неверный ID рецепта.\");\r\n            return;\r\n        }\r\n        Log.d(TAG, \"Загрузка рецепта с ID: \" + recipeId + \" из кэша репозитория\");\r\n        executeIfActive(() -> {\r\n            // Загружаем весь список из кэша\r\n            RecipeRepository.Result<List<Recipe>> cachedResult = recipeRepository.loadFromCache();\r\n            \r\n            if (cachedResult.isSuccess()) {\r\n                List<Recipe> cachedRecipes = ((RecipeRepository.Result.Success<List<Recipe>>) cachedResult).getData();\r\n                Recipe foundRecipe = null;\r\n                // Ищем нужный рецепт в списке\r\n                for (Recipe r : cachedRecipes) {\r\n                    if (r.getId() == recipeId) {\r\n                        foundRecipe = r;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (foundRecipe != null) {\r\n                    recipe.postValue(foundRecipe);\r\n                    isLiked.postValue(foundRecipe.isLiked()); // Устанавливаем статус лайка\r\n                    checkEditPermission(foundRecipe.getUserId()); // Проверяем права\r\n                    Log.d(TAG, \"Рецепт ID \" + recipeId + \" найден в кэше: \" + foundRecipe.getTitle());\r\n                } else {\r\n                    errorMessage.postValue(\"Рецепт с ID \" + recipeId + \" не найден в кэше.\");\r\n                    Log.e(TAG, \"Рецепт с ID \" + recipeId + \" не найден в загруженном кэше.\");\r\n                }\r\n            } else {\r\n                // Ошибка загрузки из кэша\r\n                String error = ((RecipeRepository.Result.Error<List<Recipe>>) cachedResult).getErrorMessage();\r\n                errorMessage.postValue(\"Ошибка загрузки из кэша: \" + error);\r\n                Log.e(TAG, \"Ошибка загрузки рецептов из кэша: \" + error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Проверяет, имеет ли пользователь права на редактирование рецепта\r\n     */\r\n    private void checkEditPermission(String recipeUserId) {\r\n        String currentUserId = preferences.getString(\"userId\", \"0\");\r\n        int permission = preferences.getInt(\"permission\", 1);\r\n        \r\n        // Пользователь может редактировать, если он автор или администратор\r\n        boolean canEdit = (recipeUserId != null && recipeUserId.equals(currentUserId)) || permission == 2;\r\n        hasEditPermission.postValue(canEdit);\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с информацией о рецепте\r\n     */\r\n    public LiveData<Recipe> getRecipe() {\r\n        return recipe;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с состоянием лайка\r\n     */\r\n    public LiveData<Boolean> isLiked() {\r\n        return isLiked;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с состоянием процесса удаления\r\n     */\r\n    public LiveData<Boolean> isDeleting() {\r\n        return isDeleting;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с результатом удаления\r\n     */\r\n    public LiveData<Boolean> isDeleteSuccess() {\r\n        return deleteSuccess;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с текстом ошибки\r\n     */\r\n    public LiveData<String> getErrorMessage() {\r\n        return errorMessage;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с информацией о наличии прав на редактирование\r\n     */\r\n    public LiveData<Boolean> hasEditPermission() {\r\n        return hasEditPermission;\r\n    }\r\n    \r\n    /**\r\n     * Изменяет состояние \"лайка\" для рецепта\r\n     */\r\n    public void toggleLike() {\r\n        Recipe currentRecipe = recipe.getValue();\r\n        if (currentRecipe == null) {\r\n            errorMessage.postValue(\"Данные рецепта еще не загружены.\");\r\n            return;\r\n        }\r\n        \r\n        String userId = preferences.getString(\"userId\", \"0\");\r\n        if (userId.equals(\"0\")) {\r\n            errorMessage.postValue(\"Для добавления в избранное необходимо войти в аккаунт\");\r\n            return;\r\n        }\r\n        \r\n        boolean currentLikeState = isLiked.getValue() != null ? isLiked.getValue() : false;\r\n        boolean newLikeState = !currentLikeState;\r\n        isLiked.postValue(newLikeState);\r\n        currentRecipe.setLiked(newLikeState);\r\n        \r\n        sendLikeRequest(userId, currentRecipe.getId(), newLikeState);\r\n        \r\n        executeIfActive(() -> {\r\n            localRepository.updateLikeStatus(currentRecipe.getId(), newLikeState);\r\n            Log.d(TAG, \"Статус лайка для ID \" + currentRecipe.getId() + \" обновлен в локальной БД на \" + newLikeState);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Отправляет запрос на сервер для изменения статуса \"лайк\"\r\n     */\r\n    private void sendLikeRequest(String userId, int recipeId, boolean isLiked) {\r\n        try {\r\n            JSONObject jsonObject = new JSONObject();\r\n            jsonObject.put(\"recipeId\", recipeId);\r\n            jsonObject.put(\"userId\", userId);\r\n            \r\n            String jsonBody = jsonObject.toString();\r\n            Log.d(TAG, \"Отправка запроса лайка: \" + jsonBody);\r\n            \r\n            RequestBody body = RequestBody.create(jsonBody, JSON);\r\n            \r\n            Request request = new Request.Builder()\r\n                    .url(com.example.cooking.config.ServerConfig.getFullUrl(\"/like\"))\r\n                    .post(body)\r\n                    .build();\r\n            \r\n            client.newCall(request).enqueue(new Callback() {\r\n                @Override\r\n                public void onFailure(@NonNull Call call, @NonNull IOException e) {\r\n                    Log.e(TAG, \"Ошибка сети при изменении лайка\", e);\r\n                    errorMessage.postValue(\"Ошибка сети: \" + e.getMessage());\r\n                }\r\n                \r\n                @Override\r\n                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {\r\n                    if (response.isSuccessful()) {\r\n                        Log.d(TAG, \"Успешный ответ от сервера на изменение лайка\");\r\n                    } else {\r\n                        Log.e(TAG, \"Ошибка сервера при изменении лайка: \" + response.code() + \" \" + response.message());\r\n                        String responseBody = response.body() != null ? response.body().string() : \"No body\";\r\n                        Log.e(TAG, \"Тело ответа: \" + responseBody);\r\n                        errorMessage.postValue(\"Ошибка сервера: \" + response.code());\r\n                    }\r\n                    if (response.body() != null) {\r\n                        response.body().close();\r\n                    }\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка при создании запроса на изменение лайка\", e);\r\n            errorMessage.postValue(\"Ошибка приложения: \" + e.getMessage());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Выполняет удаление рецепта\r\n     * @param recipeId ID удаляемого рецепта\r\n     */\r\n    public void deleteRecipe(int recipeId) {\r\n        Recipe currentRecipe = recipe.getValue();\r\n        if (currentRecipe == null || currentRecipe.getId() != recipeId) {\r\n            Log.e(TAG, \"Невозможно удалить: текущий рецепт не совпадает с ID \" + recipeId);\r\n            errorMessage.postValue(\"Ошибка удаления: Несоответствие данных.\");\r\n            return;\r\n        }\r\n        \r\n        String currentUserId = preferences.getString(\"userId\", \"0\");\r\n        int permission = preferences.getInt(\"permission\", 1);\r\n        \r\n        boolean canDelete = (currentRecipe.getUserId() != null && currentRecipe.getUserId().equals(currentUserId)) || permission == 2;\r\n        if (!canDelete) {\r\n            errorMessage.postValue(\"У вас нет прав на удаление этого рецепта.\");\r\n            return;\r\n        }\r\n        \r\n        isDeleting.postValue(true);\r\n        \r\n        recipeDeleter.deleteRecipe(recipeId, currentUserId, permission,\r\n                new RecipeDeleter.DeleteRecipeCallback() {\r\n            @Override\r\n            public void onDeleteSuccess() {\r\n                Log.d(TAG, \"Рецепт с ID \" + recipeId + \" успешно удален.\");\r\n                recipe.postValue(null);\r\n                isDeleting.postValue(false);\r\n                deleteSuccess.postValue(true);\r\n                // Удаляем рецепт из локальной базы данных\r\n                localRepository.deleteRecipe(recipeId);\r\n            }\r\n            @Override\r\n            public void onDeleteFailure(String error) {\r\n                Log.e(TAG, \"Ошибка удаления рецепта ID \" + recipeId + \": \" + error);\r\n                errorMessage.postValue(\"Ошибка удаления: \" + error);\r\n                isDeleting.postValue(false);\r\n                deleteSuccess.postValue(false);\r\n            }\r\n        });\r\n    }\r\n    \r\n    @Override\r\n    protected void onCleared() {\r\n        super.onCleared();\r\n        executor.shutdown();\r\n    }\r\n\r\n    /**\r\n     * Выполняет задачу в фоновом потоке, если ViewModel активна.\r\n     */\r\n    private void executeIfActive(Runnable task) {\r\n        if (!executor.isShutdown()) {\r\n            executor.execute(task);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java b/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java
--- a/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java	(revision 13d31353b547022b462dac88d1070f6fc5bae46e)
+++ b/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java	(date 1745092749986)
@@ -77,7 +77,6 @@
         executeIfActive(() -> {
             // Загружаем весь список из кэша
             RecipeRepository.Result<List<Recipe>> cachedResult = recipeRepository.loadFromCache();
-            
             if (cachedResult.isSuccess()) {
                 List<Recipe> cachedRecipes = ((RecipeRepository.Result.Success<List<Recipe>>) cachedResult).getData();
                 Recipe foundRecipe = null;
@@ -88,21 +87,52 @@
                         break;
                     }
                 }
-                
                 if (foundRecipe != null) {
                     recipe.postValue(foundRecipe);
                     isLiked.postValue(foundRecipe.isLiked()); // Устанавливаем статус лайка
                     checkEditPermission(foundRecipe.getUserId()); // Проверяем права
                     Log.d(TAG, "Рецепт ID " + recipeId + " найден в кэше: " + foundRecipe.getTitle());
                 } else {
-                    errorMessage.postValue("Рецепт с ID " + recipeId + " не найден в кэше.");
-                    Log.e(TAG, "Рецепт с ID " + recipeId + " не найден в загруженном кэше.");
+                    // Если рецепт не найден в кэше, пробуем загрузить с сервера
+                    fetchRecipeFromServer(recipeId);
                 }
             } else {
                 // Ошибка загрузки из кэша
                 String error = ((RecipeRepository.Result.Error<List<Recipe>>) cachedResult).getErrorMessage();
-                errorMessage.postValue("Ошибка загрузки из кэша: " + error);
                 Log.e(TAG, "Ошибка загрузки рецептов из кэша: " + error);
+                // Пробуем загрузить с сервера, если кэш пуст
+                fetchRecipeFromServer(recipeId);
+            }
+        });
+    }
+
+    private void fetchRecipeFromServer(int recipeId) {
+        // Показываем индикатор загрузки, если есть
+        // Можно добавить LiveData для прогресса
+        recipeRepository.getRecipes(new RecipeRepository.RecipesCallback() {
+            @Override
+            public void onRecipesLoaded(List<Recipe> recipes) {
+                Recipe foundRecipe = null;
+                for (Recipe r : recipes) {
+                    if (r.getId() == recipeId) {
+                        foundRecipe = r;
+                        break;
+                    }
+                }
+                if (foundRecipe != null) {
+                    recipe.postValue(foundRecipe);
+                    isLiked.postValue(foundRecipe.isLiked());
+                    checkEditPermission(foundRecipe.getUserId());
+                    Log.d(TAG, "Рецепт ID " + recipeId + " найден после загрузки с сервера: " + foundRecipe.getTitle());
+                } else {
+                    errorMessage.postValue("Рецепт с ID " + recipeId + " не найден на сервере.");
+                    Log.e(TAG, "Рецепт с ID " + recipeId + " не найден на сервере.");
+                }
+            }
+            @Override
+            public void onDataNotAvailable(String error) {
+                errorMessage.postValue("Ошибка загрузки рецепта: " + error + "\nПроверьте подключение к интернету и попробуйте обновить страницу.");
+                Log.e(TAG, "Ошибка загрузки рецепта с сервера: " + error);
             }
         });
     }
Index: app/src/main/java/com/example/cooking/data/repositories/RecipeRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.data.repositories;\r\n\r\nimport android.content.Context;\r\nimport android.content.SharedPreferences;\r\nimport android.net.ConnectivityManager;\r\nimport android.net.NetworkInfo;\r\nimport android.util.Log;\r\n\r\nimport com.example.cooking.Recipe.Ingredient;\r\nimport com.example.cooking.Recipe.Recipe;\r\nimport com.example.cooking.Recipe.Step;\r\nimport com.example.cooking.config.ServerConfig;\r\nimport com.example.cooking.network.api.RecipeApi;\r\nimport com.example.cooking.network.responses.RecipesResponse;\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.GsonBuilder;\r\nimport com.google.gson.reflect.TypeToken;\r\n\r\nimport org.json.JSONArray;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Type;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport okhttp3.Cache;\r\nimport okhttp3.CacheControl;\r\nimport okhttp3.Interceptor;\r\nimport okhttp3.OkHttpClient;\r\nimport okhttp3.Request;\r\nimport okhttp3.Response;\r\nimport okhttp3.logging.HttpLoggingInterceptor;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Retrofit;\r\nimport retrofit2.converter.gson.GsonConverterFactory;\r\n\r\n/**\r\n * Репозиторий для управления данными рецептов с использованием всех преимуществ Retrofit.\r\n */\r\npublic class RecipeRepository {\r\n    private static final String TAG = \"RecipeRepository\";\r\n    private static final String API_URL = ServerConfig.BASE_API_URL;\r\n    \r\n    // Настройки кэша\r\n    private static final long CACHE_SIZE = 10 * 1024 * 1024; // 10 МБ\r\n    private static final String CACHE_CONTROL_HEADER = \"Cache-Control\";\r\n    private static final int MAX_AGE = 60 * 4; // 4 минуты для онлайн кэша\r\n    private static final int MAX_STALE = 60 * 60 * 24 * 7; // 7 дней для оффлайн кэша\r\n    \r\n    // Настройки кэша в SharedPreferences\r\n    private static final String RECIPES_CACHE_KEY = \"cached_recipes\";\r\n    private static final String LAST_UPDATE_TIME_KEY = \"recipes_last_update_time\";\r\n    private static final String PREF_NAME = \"recipe_cache\";\r\n    private static final long CACHE_EXPIRATION_TIME = (60 * 60 * 1000) / 15; // 4 минуты\r\n    \r\n    private final Context context;\r\n    private final RecipeApi recipeApi;\r\n    \r\n    private static final Gson gson = new Gson(); // Экземпляр Gson\r\n    \r\n    public interface RecipesCallback {\r\n        void onRecipesLoaded(List<Recipe> recipes);\r\n        void onDataNotAvailable(String error);\r\n    }\r\n    \r\n    public RecipeRepository(Context context) {\r\n        this.context = context;\r\n        \r\n        // Создаем HTTP кэш\r\n        File cacheDir = new File(context.getCacheDir(), \"http-cache\");\r\n        Cache cache = new Cache(cacheDir, CACHE_SIZE);\r\n        \r\n        // логирование для отладки\r\n        HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();\r\n        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\r\n        \r\n        //интерцептор для добавления заголовков кэширования\r\n        Interceptor cacheInterceptor = chain -> {\r\n            Request request = chain.request();\r\n            \r\n            // Всегда сначала пробуем загрузить свежие данные с сервера\r\n            if (isNetworkAvailable()) {\r\n                // Запрос к серверу с указанием не использовать кэш\r\n                request = request.newBuilder()\r\n                        .cacheControl(CacheControl.FORCE_NETWORK)\r\n                        .build();\r\n                \r\n                Log.d(TAG, \"Загрузка данных с сервера\");\r\n            } else {\r\n                // Если сети нет, пробуем использовать кэш\r\n                CacheControl cacheControl = new CacheControl.Builder()\r\n                        .maxStale(MAX_STALE, TimeUnit.SECONDS)\r\n                        .build();\r\n                \r\n                request = request.newBuilder()\r\n                        .cacheControl(cacheControl)\r\n                        .build();\r\n                \r\n                Log.d(TAG, \"Нет сети, используем оффлайн кэш\");\r\n            }\r\n            \r\n            Response response = chain.proceed(request);\r\n            \r\n            // Кэшируем ответ для будущего использования в оффлайн режиме\r\n            return response.newBuilder()\r\n                    .removeHeader(\"Pragma\")\r\n                    .header(CACHE_CONTROL_HEADER, \"public, max-age=\" + MAX_AGE)\r\n                    .build();\r\n        };\r\n        \r\n        //  интерцептор для перехвата всех запросов\r\n        Interceptor requestInterceptor = chain -> {\r\n            Request original = chain.request();\r\n            \r\n            // Добавляем общие заголовки к запросу\r\n            Request request = original.newBuilder()\r\n                    .header(\"Accept\", \"application/json\")\r\n                    .method(original.method(), original.body())\r\n                    .build();\r\n            \r\n            return chain.proceed(request);\r\n        };\r\n        \r\n        // Настраиваем OkHttpClient с кэшем и интерцепторами\r\n        OkHttpClient httpClient = new OkHttpClient.Builder()\r\n                .cache(cache)\r\n                .addInterceptor(requestInterceptor)\r\n                .addNetworkInterceptor(cacheInterceptor)\r\n                .addInterceptor(loggingInterceptor)\r\n                .connectTimeout(30, TimeUnit.SECONDS)\r\n                .readTimeout(30, TimeUnit.SECONDS)\r\n                .writeTimeout(30, TimeUnit.SECONDS)\r\n                .build();\r\n        \r\n        // Настраиваем Gson для более безопасного парсинга JSON\r\n        Gson gsonConverter = new GsonBuilder()\r\n                .setLenient()\r\n                .create();\r\n        \r\n        //  Retrofit с настроенным клиентом и конвертером\r\n        Retrofit retrofit = new Retrofit.Builder()\r\n                .baseUrl(API_URL + \"/\")\r\n                .client(httpClient)\r\n                .addConverterFactory(GsonConverterFactory.create(gsonConverter))\r\n                .build();\r\n        \r\n        //  имплементацию API\r\n        recipeApi = retrofit.create(RecipeApi.class);\r\n    }\r\n    \r\n    /**\r\n     * Получает рецепты с сервера.\r\n     */\r\n    public void getRecipes(final RecipesCallback callback) {\r\n        // Если нет сети, сразу пробуем загрузить из кэша\r\n        if (!isNetworkAvailable()) {\r\n            Log.d(TAG, \"Нет подключения к интернету, пробуем загрузить из кэша\");\r\n            Result<List<Recipe>> cachedResult = loadFromCache();\r\n            if (cachedResult.isSuccess()) {\r\n                List<Recipe> recipes = ((Result.Success<List<Recipe>>) cachedResult).getData();\r\n                Log.d(TAG, \"Загружено из кэша рецептов: \" + recipes.size());\r\n                callback.onRecipesLoaded(recipes);\r\n                return;\r\n            } else {\r\n                Log.e(TAG, \"Кэш недоступен: \" + ((Result.Error<List<Recipe>>) cachedResult).getErrorMessage());\r\n                callback.onDataNotAvailable(\"Нет подключения к интернету и нет данных в кэше\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Вызываем API асинхронно, используя enqueue\r\n        Call<RecipesResponse> call = recipeApi.getRecipes();\r\n        call.enqueue(new Callback<RecipesResponse>() {\r\n            @Override\r\n            public void onResponse(Call<RecipesResponse> call, retrofit2.Response<RecipesResponse> response) {\r\n                if (response.isSuccessful()) {\r\n                    RecipesResponse recipesResponse = response.body();\r\n                    if (recipesResponse != null && recipesResponse.isSuccess() && recipesResponse.getRecipes() != null) {\r\n                        List<Recipe> recipes = recipesResponse.getRecipes();\r\n                        Log.d(TAG, \"Загружено с сервера рецептов: \" + recipes.size());\r\n                        // Сохраняем в кэш для RecipeSearchService и для оффлайн режима\r\n                        saveToCache(recipes);\r\n                        callback.onRecipesLoaded(recipes);\r\n                    } else {\r\n                        String errorMsg = response.body() != null \r\n                                ? \"Ошибка в ответе сервера: \" + recipesResponse.getMessage()\r\n                                : \"Пустой ответ от сервера\";\r\n                        Log.e(TAG, errorMsg);\r\n                        // Пробуем загрузить из кэша при ошибке сервера\r\n                        tryLoadFromCache(errorMsg, callback);\r\n                    }\r\n                } else {\r\n                    String errorBody = null;\r\n                    try {\r\n                        errorBody = response.errorBody() != null ? response.errorBody().string() : null;\r\n                    } catch (IOException e) {\r\n                        Log.e(TAG, \"Ошибка при чтении errorBody\", e);\r\n                    }\r\n                    \r\n                    String errorMsg = \"Ошибка HTTP \" + response.code();\r\n                    if (errorBody != null && !errorBody.isEmpty()) {\r\n                        errorMsg += \": \" + errorBody;\r\n                    }\r\n                    \r\n                    Log.e(TAG, errorMsg);\r\n                    // Пробуем загрузить из кэша при ошибке HTTP\r\n                    tryLoadFromCache(errorMsg, callback);\r\n                }\r\n            }\r\n            \r\n            @Override\r\n            public void onFailure(Call<RecipesResponse> call, Throwable t) {\r\n                Log.e(TAG, \"Ошибка сети: \" + t.getMessage(), t);\r\n                \r\n                String errorMsg;\r\n                if (!isNetworkAvailable()) {\r\n                    errorMsg = \"Нет подключения к интернету\";\r\n                } else {\r\n                    errorMsg = \"Ошибка сети: \" + t.getMessage();\r\n                }\r\n                \r\n                Log.e(TAG, errorMsg);\r\n                // Пробуем загрузить из кэша при ошибке сети\r\n                tryLoadFromCache(errorMsg, callback);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Вспомогательный метод для загрузки данных из кэша при ошибках сети или сервера\r\n     */\r\n    private void tryLoadFromCache(String errorMsg, RecipesCallback callback) {\r\n        Result<List<Recipe>> cachedResult = loadFromCache();\r\n        if (cachedResult.isSuccess()) {\r\n            List<Recipe> recipes = ((Result.Success<List<Recipe>>) cachedResult).getData();\r\n            Log.d(TAG, \"Загружены данные из кэша после ошибки сети: \" + recipes.size() + \" рецептов\");\r\n            callback.onRecipesLoaded(recipes);\r\n        } else {\r\n            // Если и кэш недоступен, возвращаем ошибку\r\n            callback.onDataNotAvailable(errorMsg + \". Кэш также недоступен.\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Очищает кэш рецептов. Используется при добавлении/удалении/лайке рецептов.\r\n     */\r\n    public void clearCache() {\r\n        try {\r\n            // Очищаем SharedPreferences кэш\r\n            SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor = prefs.edit();\r\n            editor.remove(RECIPES_CACHE_KEY);\r\n            editor.remove(LAST_UPDATE_TIME_KEY);\r\n            editor.apply();\r\n            \r\n            // Очищаем HTTP кэш\r\n            try {\r\n                File cacheDir = new File(context.getCacheDir(), \"http-cache\");\r\n                deleteDir(cacheDir);\r\n                Log.d(TAG, \"HTTP кэш очищен\");\r\n            } catch (Exception e) {\r\n                Log.e(TAG, \"Ошибка при очистке HTTP кэша\", e);\r\n            }\r\n            \r\n            Log.d(TAG, \"Кэш успешно очищен\");\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка при очистке кэша: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n    \r\n    private boolean deleteDir(File dir) {\r\n        if (dir != null && dir.isDirectory()) {\r\n            String[] children = dir.list();\r\n            if (children != null) {\r\n                for (String child : children) {\r\n                    boolean success = deleteDir(new File(dir, child));\r\n                    if (!success) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dir != null && dir.delete();\r\n    }\r\n    \r\n    /**\r\n     * Сохраняет список рецептов в кэш SharedPreferences.\r\n     * Используется для RecipeSearchService.\r\n     */\r\n    private void saveToCache(List<Recipe> recipes) {\r\n        try {\r\n            JSONArray recipesArray = new JSONArray();\r\n            for (Recipe recipe : recipes) {\r\n                JSONObject recipeJson = new JSONObject();\r\n                recipeJson.put(\"id\", recipe.getId());\r\n                recipeJson.put(\"title\", recipe.getTitle());\r\n                recipeJson.put(\"ingredients\", gson.toJson(recipe.getIngredients()));\r\n                recipeJson.put(\"instructions\", gson.toJson(recipe.getSteps()));\r\n                recipeJson.put(\"created_at\", recipe.getCreated_at());\r\n                recipeJson.put(\"userId\", recipe.getUserId());\r\n                recipeJson.put(\"photo\", recipe.getPhoto_url());\r\n                recipeJson.put(\"isLiked\", recipe.isLiked());\r\n                recipesArray.put(recipeJson);\r\n            }\r\n            SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor = prefs.edit();\r\n            editor.putString(RECIPES_CACHE_KEY, recipesArray.toString());\r\n            editor.putLong(LAST_UPDATE_TIME_KEY, System.currentTimeMillis());\r\n            editor.apply();\r\n            Log.d(TAG, \"Сохранено в SharedPreferences кэш рецептов: \" + recipes.size());\r\n        } catch (JSONException e) {\r\n            Log.e(TAG, \"Ошибка при кэшировании рецептов в SharedPreferences\", e);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Загружает рецепты из кэша SharedPreferences.\r\n     * Используется в RecipeSearchService для поиска.\r\n     */\r\n    public Result<List<Recipe>> loadFromCache() {\r\n        try {\r\n            SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);\r\n            String cachedRecipes = prefs.getString(RECIPES_CACHE_KEY, null);\r\n            if (cachedRecipes != null && !cachedRecipes.isEmpty()) {\r\n                JSONArray recipesArray = new JSONArray(cachedRecipes);\r\n                List<Recipe> recipes = new ArrayList<>();\r\n                // Определяем типы для Gson\r\n                Type ingredientListType = new TypeToken<ArrayList<Ingredient>>() {}.getType();\r\n                Type stepListType = new TypeToken<ArrayList<Step>>() {}.getType();\r\n\r\n                for (int i = 0; i < recipesArray.length(); i++) {\r\n                    JSONObject recipeJson = recipesArray.getJSONObject(i);\r\n                    Recipe recipe = new Recipe();\r\n                    recipe.setId(recipeJson.optInt(\"id\", 0));\r\n                    recipe.setTitle(recipeJson.optString(\"title\", \"\"));\r\n\r\n                    // Десериализуем JSON строки обратно в списки\r\n                    String ingredientsString = recipeJson.optString(\"ingredients\", \"\");\r\n                    String stepsString = recipeJson.optString(\"instructions\", \"\");\r\n\r\n                    List<Ingredient> ingredients = gson.fromJson(ingredientsString, ingredientListType);\r\n                    List<Step> steps = gson.fromJson(stepsString, stepListType);\r\n\r\n                     // Проверка на null после десериализации\r\n                    recipe.setIngredients(ingredients == null ? new ArrayList<>() : new ArrayList<>(ingredients));\r\n                    recipe.setSteps(steps == null ? new ArrayList<>() : new ArrayList<>(steps));\r\n\r\n                    recipe.setPhoto_url(recipeJson.optString(\"photo\", \"\"));\r\n                    recipe.setCreated_at(recipeJson.optString(\"created_at\", \"\"));\r\n                    recipe.setUserId(recipeJson.optString(\"userId\", \"\"));\r\n                    recipe.setLiked(recipeJson.optBoolean(\"isLiked\", false));\r\n                    recipes.add(recipe);\r\n                }\r\n                 Log.d(TAG, \"Загружено из SharedPreferences кэша рецептов: \" + recipes.size());\r\n                return new Result.Success<>(recipes);\r\n            } else {\r\n                 Log.d(TAG, \"SharedPreferences кэш рецептов пуст\");\r\n                return new Result.Error<>(\"Кэш пуст\");\r\n            }\r\n        } catch (JSONException e) {\r\n            Log.e(TAG, \"Ошибка при чтении кэша из SharedPreferences\", e);\r\n            return new Result.Error<>(\"Ошибка при чтении кэша: \" + e.getMessage());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Проверяет, истек ли срок действия кэша.\r\n     */\r\n    private boolean isCacheExpired() {\r\n        SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);\r\n        long lastUpdateTime = prefs.getLong(LAST_UPDATE_TIME_KEY, 0);\r\n        boolean expired = System.currentTimeMillis() - lastUpdateTime > CACHE_EXPIRATION_TIME;\r\n        Log.d(TAG, \"Проверка истечения SharedPreferences кэша: \" + (expired ? \"Истек\" : \"Актуален\"));\r\n        return expired;\r\n    }\r\n    \r\n    /**\r\n     * Проверяет доступность сети.\r\n     */\r\n    private boolean isNetworkAvailable() {\r\n        ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();\r\n        return activeNetworkInfo != null && activeNetworkInfo.isConnected();\r\n    }\r\n    \r\n    /**\r\n     * Класс результата операции, используемый в RecipeSearchService.\r\n     */\r\n    public abstract static class Result<T> {\r\n        public abstract boolean isSuccess();\r\n        \r\n        public static class Success<T> extends Result<T> {\r\n            private final T data;\r\n            \r\n            public Success(T data) {\r\n                this.data = data;\r\n            }\r\n            \r\n            public T getData() {\r\n                return data;\r\n            }\r\n            \r\n            @Override\r\n            public boolean isSuccess() {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        public static class Error<T> extends Result<T> {\r\n            private final String errorMessage;\r\n            \r\n            public Error(String errorMessage) {\r\n                this.errorMessage = errorMessage;\r\n            }\r\n            \r\n            public String getErrorMessage() {\r\n                return errorMessage;\r\n            }\r\n            \r\n            @Override\r\n            public boolean isSuccess() {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/data/repositories/RecipeRepository.java b/app/src/main/java/com/example/cooking/data/repositories/RecipeRepository.java
--- a/app/src/main/java/com/example/cooking/data/repositories/RecipeRepository.java	(revision 13d31353b547022b462dac88d1070f6fc5bae46e)
+++ b/app/src/main/java/com/example/cooking/data/repositories/RecipeRepository.java	(date 1745092750009)
@@ -325,46 +325,17 @@
      */
     public Result<List<Recipe>> loadFromCache() {
         try {
-            SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
-            String cachedRecipes = prefs.getString(RECIPES_CACHE_KEY, null);
-            if (cachedRecipes != null && !cachedRecipes.isEmpty()) {
-                JSONArray recipesArray = new JSONArray(cachedRecipes);
-                List<Recipe> recipes = new ArrayList<>();
-                // Определяем типы для Gson
-                Type ingredientListType = new TypeToken<ArrayList<Ingredient>>() {}.getType();
-                Type stepListType = new TypeToken<ArrayList<Step>>() {}.getType();
-
-                for (int i = 0; i < recipesArray.length(); i++) {
-                    JSONObject recipeJson = recipesArray.getJSONObject(i);
-                    Recipe recipe = new Recipe();
-                    recipe.setId(recipeJson.optInt("id", 0));
-                    recipe.setTitle(recipeJson.optString("title", ""));
-
-                    // Десериализуем JSON строки обратно в списки
-                    String ingredientsString = recipeJson.optString("ingredients", "");
-                    String stepsString = recipeJson.optString("instructions", "");
-
-                    List<Ingredient> ingredients = gson.fromJson(ingredientsString, ingredientListType);
-                    List<Step> steps = gson.fromJson(stepsString, stepListType);
-
-                     // Проверка на null после десериализации
-                    recipe.setIngredients(ingredients == null ? new ArrayList<>() : new ArrayList<>(ingredients));
-                    recipe.setSteps(steps == null ? new ArrayList<>() : new ArrayList<>(steps));
-
-                    recipe.setPhoto_url(recipeJson.optString("photo", ""));
-                    recipe.setCreated_at(recipeJson.optString("created_at", ""));
-                    recipe.setUserId(recipeJson.optString("userId", ""));
-                    recipe.setLiked(recipeJson.optBoolean("isLiked", false));
-                    recipes.add(recipe);
-                }
-                 Log.d(TAG, "Загружено из SharedPreferences кэша рецептов: " + recipes.size());
+            RecipeLocalRepository localRepository = new RecipeLocalRepository(context);
+            List<Recipe> recipes = localRepository.getAllRecipesList();
+            if (recipes != null && !recipes.isEmpty()) {
+                Log.d(TAG, "Загружено из Room кэша рецептов: " + recipes.size());
                 return new Result.Success<>(recipes);
             } else {
-                 Log.d(TAG, "SharedPreferences кэш рецептов пуст");
+                Log.d(TAG, "Room кэш рецептов пуст");
                 return new Result.Error<>("Кэш пуст");
             }
-        } catch (JSONException e) {
-            Log.e(TAG, "Ошибка при чтении кэша из SharedPreferences", e);
+        } catch (Exception e) {
+            Log.e(TAG, "Ошибка при чтении кэша из Room", e);
             return new Result.Error<>("Ошибка при чтении кэша: " + e.getMessage());
         }
     }
Index: app/src/main/java/com/example/cooking/network/services/RecipeManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.network.services;\r\n\r\nimport android.content.Context;\r\nimport android.net.ConnectivityManager;\r\nimport android.net.NetworkInfo;\r\nimport android.util.Log;\r\n\r\nimport com.example.cooking.Recipe.Ingredient;\r\nimport com.example.cooking.Recipe.Step;\r\nimport com.example.cooking.data.repositories.RecipeRepository;\r\nimport com.example.cooking.network.api.RecipeApiService;\r\nimport com.google.gson.Gson;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport okhttp3.MediaType;\r\nimport okhttp3.MultipartBody;\r\nimport okhttp3.OkHttpClient;\r\nimport okhttp3.RequestBody;\r\nimport okhttp3.ResponseBody;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\nimport retrofit2.Retrofit;\r\nimport retrofit2.converter.gson.GsonConverterFactory;\r\n\r\n/**\r\n * Менеджер для работы с API рецептов через Retrofit\r\n * Используется для добавления и редактирования рецептов\r\n */\r\npublic class RecipeManager {\r\n    private static final String TAG = \"RecipeManager\";\r\n    private static final String API_URL = \"http://r1.veroid.network:10009\";\r\n    \r\n    // Увеличенные таймауты для стабильности\r\n    private static final int CONNECT_TIMEOUT = 30; // 30 секунд\r\n    private static final int READ_TIMEOUT = 60; // 60 секунд\r\n    private static final int WRITE_TIMEOUT = 60; // 60 секунд\r\n    private static final int MAX_RETRY_ATTEMPTS = 3; // Максимальное количество повторных попыток\r\n    \r\n    private final RecipeApiService apiService;\r\n    private final Context context;\r\n    private static final Gson gson = new Gson();\r\n\r\n    public void updateRecipe(Integer currentRecipeId, String currentTitle, List<Ingredient> currentIngredients, List<Step> currentSteps, byte[] bytes, String userId, int permission, RecipeSaveCallback recipeSaveCallback) {\r\n    }\r\n\r\n    /**\r\n     * Интерфейс для обратного вызова результата добавления/редактирования рецепта\r\n     */\r\n    public interface RecipeSaveCallback {\r\n        void onSuccess(String message);\r\n        void onFailure(String error);\r\n    }\r\n    \r\n    public RecipeManager(Context context) {\r\n        this.context = context;\r\n        \r\n        // Создаем OkHttpClient с увеличенными таймаутами\r\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\r\n                .connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)\r\n                .readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)\r\n                .writeTimeout(WRITE_TIMEOUT, TimeUnit.SECONDS)\r\n                .retryOnConnectionFailure(true) // Включаем автоматические повторные попытки\r\n                .build();\r\n        \r\n        // Создаем Retrofit с настроенным OkHttpClient\r\n        Retrofit retrofit = new Retrofit.Builder()\r\n                .baseUrl(API_URL)\r\n                .client(okHttpClient)\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                .build();\r\n        \r\n        // Создаем API сервис\r\n        apiService = retrofit.create(RecipeApiService.class);\r\n    }\r\n    \r\n    /**\r\n     * Проверяет наличие интернет-соединения\r\n     * @return true, если есть подключение к интернету\r\n     */\r\n    private boolean isNetworkAvailable() {\r\n        ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        if (connectivityManager != null) {\r\n            NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();\r\n            return activeNetworkInfo != null && activeNetworkInfo.isConnected();\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Добавляет или редактирует рецепт\r\n     * @param title Название рецепта\r\n     * @param ingredients Список ингредиентов\r\n     * @param steps Список шагов\r\n     * @param userId ID пользователя\r\n     * @param recipeId ID рецепта (null для нового рецепта)\r\n     * @param imageBytes Изображение рецепта (может быть null)\r\n     * @param callback Обратный вызов результата\r\n     */\r\n    public void saveRecipe(String title, List<Ingredient> ingredients, List<Step> steps,\r\n                          String userId, Integer recipeId, byte[] imageBytes,\r\n                          RecipeSaveCallback callback) {\r\n        \r\n        // Проверяем наличие интернет-соединения\r\n        if (!isNetworkAvailable()) {\r\n            callback.onFailure(\"Отсутствует подключение к интернету. Пожалуйста, проверьте подключение и попробуйте снова.\");\r\n            return;\r\n        }\r\n        \r\n        // Сериализуем списки в JSON\r\n        String ingredientsJson = gson.toJson(ingredients);\r\n        String stepsJson = gson.toJson(steps);\r\n        \r\n        Log.d(TAG, \"Сохранение рецепта:\" +\r\n                \" title: \" + title +\r\n                \", ingredients: \" + ingredientsJson +\r\n                \", steps: \" + stepsJson +\r\n                \", userId: \" + userId +\r\n                \", recipeId: \" + (recipeId != null ? recipeId : \"новый рецепт\") +\r\n                \", imageBytes: \" + (imageBytes != null ? imageBytes.length + \" байт\" : \"нет\"));\r\n        \r\n        try {\r\n            // Создаем RequestBody для текстовых полей (включая JSON-строки)\r\n            RequestBody titleBody = RequestBody.create(title, MediaType.parse(\"text/plain\"));\r\n            RequestBody ingredientsBody = RequestBody.create(ingredientsJson, MediaType.parse(\"application/json\"));\r\n            RequestBody stepsBody = RequestBody.create(stepsJson, MediaType.parse(\"application/json\"));\r\n            RequestBody userIdBody = RequestBody.create(userId, MediaType.parse(\"text/plain\"));\r\n            RequestBody recipeIdBody = RequestBody.create(\r\n                    recipeId != null ? recipeId.toString() : \"\", \r\n                    MediaType.parse(\"text/plain\")\r\n            );\r\n            \r\n            Call<ResponseBody> call;\r\n            \r\n            // Если есть изображение, используем метод с фото\r\n            if (imageBytes != null && imageBytes.length > 0) {\r\n                String fileName = \"recipe_\" + System.currentTimeMillis() + \".jpg\";\r\n                RequestBody requestFile = RequestBody.create(imageBytes, MediaType.parse(\"image/jpeg\"));\r\n                MultipartBody.Part photoPart = MultipartBody.Part.createFormData(\"photo\", fileName, requestFile);\r\n                \r\n                call = apiService.addOrUpdateRecipe(\r\n                        titleBody, ingredientsBody, stepsBody, userIdBody, recipeIdBody, photoPart\r\n                );\r\n                Log.d(TAG, \"Отправка запроса с изображением (размер: \" + imageBytes.length + \" байт)\");\r\n            } else {\r\n                // Без изображения\r\n                // Для редактирования рецепта (с существующим ID) и без новой картинки\r\n                // важно не отправлять пустую часть 'photo', чтобы сервер сохранил существующее изображение\r\n                if (recipeId != null) {\r\n                    Log.d(TAG, \"Редактирование рецепта без изменения изображения\");\r\n                    // Создаем пустую фотографию размером 1px\r\n                    MultipartBody.Part photoPart = MultipartBody.Part.createFormData(\r\n                            \"photo\", \r\n                            \"\", \r\n                            RequestBody.create(new byte[0], MediaType.parse(\"image/jpeg\"))\r\n                    );\r\n                    call = apiService.addOrUpdateRecipe(\r\n                            titleBody, ingredientsBody, stepsBody, userIdBody, recipeIdBody, photoPart\r\n                    );\r\n                } else {\r\n                    // Для нового рецепта без картинки используем метод без фото\r\n                    Log.d(TAG, \"Создание нового рецепта без изображения\");\r\n                    call = apiService.addOrUpdateRecipeWithoutPhoto(\r\n                            titleBody, ingredientsBody, stepsBody, userIdBody, recipeIdBody\r\n                    );\r\n                }\r\n            }\r\n            \r\n            // Выполняем запрос с поддержкой повторных попыток\r\n            executeWithRetry(call, callback, 0);\r\n            \r\n        } catch (Exception e) {\r\n            // Обрабатываем любые исключения при подготовке запроса\r\n            Log.e(TAG, \"Ошибка при подготовке запроса\", e);\r\n            callback.onFailure(\"Ошибка при подготовке запроса: \" + e.getMessage());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Выполняет запрос с поддержкой повторных попыток при ошибках\r\n     * @param call Запрос Retrofit\r\n     * @param callback Обратный вызов результата\r\n     * @param retryCount Текущее количество попыток\r\n     */\r\n    private void executeWithRetry(Call<ResponseBody> call, RecipeSaveCallback callback, int retryCount) {\r\n        call.clone().enqueue(new Callback<ResponseBody>() {\r\n            @Override\r\n            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\r\n                if (response.isSuccessful()) {\r\n                    try {\r\n                        // Получаем тело ответа\r\n                        String responseStr = response.body() != null ? response.body().string() : \"\";\r\n                        Log.d(TAG, \"Ответ сервера: \" + responseStr);\r\n                        \r\n                        if (responseStr.isEmpty()) {\r\n                            Log.e(TAG, \"Получен пустой ответ от сервера\");\r\n                            if (retryCount < MAX_RETRY_ATTEMPTS) {\r\n                                // Повторяем попытку при пустом ответе\r\n                                Log.d(TAG, \"Повторная попытка #\" + (retryCount + 1));\r\n                                executeWithRetry(call, callback, retryCount + 1);\r\n                            } else {\r\n                                callback.onFailure(\"Ошибка сервера: пустой ответ после \" + MAX_RETRY_ATTEMPTS + \" попыток\");\r\n                            }\r\n                            return;\r\n                        }\r\n                        \r\n                        // Парсим JSON\r\n                        JSONObject jsonResponse = new JSONObject(responseStr);\r\n                        boolean success = jsonResponse.optBoolean(\"success\", false);\r\n                        String message = jsonResponse.optString(\"message\", \"\");\r\n                        \r\n                        if (success) {\r\n                            // Очищаем кэш рецептов, чтобы при следующем запросе получить свежие данные\r\n                            RecipeRepository repository = new RecipeRepository(context);\r\n                            repository.clearCache();\r\n                            \r\n                            // Возвращаем успех\r\n                            callback.onSuccess(message.isEmpty() ? \"Рецепт успешно сохранен\" : message);\r\n                        } else {\r\n                            // Возвращаем ошибку\r\n                            callback.onFailure(message.isEmpty() ? \"Ошибка при сохранении рецепта\" : message);\r\n                        }\r\n                    } catch (IOException | JSONException e) {\r\n                        Log.e(TAG, \"Ошибка при обработке ответа\", e);\r\n                        \r\n                        if (retryCount < MAX_RETRY_ATTEMPTS) {\r\n                            // Повторяем попытку при ошибке обработки ответа\r\n                            Log.d(TAG, \"Повторная попытка #\" + (retryCount + 1) + \" после ошибки обработки ответа\");\r\n                            executeWithRetry(call, callback, retryCount + 1);\r\n                        } else {\r\n                            callback.onFailure(\"Ошибка при обработке ответа: \" + e.getMessage());\r\n                        }\r\n                    }\r\n                } else {\r\n                    try {\r\n                        // Пытаемся получить сообщение об ошибке\r\n                        String errorBody = response.errorBody() != null ? response.errorBody().string() : null;\r\n                        Log.e(TAG, \"Ошибка HTTP \" + response.code() + \": \" + errorBody);\r\n                        \r\n                        // Специальная обработка для кода 403 (Forbidden)\r\n                        if (response.code() == 403) {\r\n                            callback.onFailure(\"У вас нет прав на редактирование этого рецепта. Только автор рецепта или администратор могут вносить изменения.\");\r\n                            return;\r\n                        }\r\n                        \r\n                        // Проверяем, можно ли повторить запрос\r\n                        if (retryCount < MAX_RETRY_ATTEMPTS && (response.code() >= 500 || response.code() == 429)) {\r\n                            // Повторяем попытку при серверных ошибках (5xx) или слишком частых запросах (429)\r\n                            Log.d(TAG, \"Повторная попытка #\" + (retryCount + 1) + \" после HTTP ошибки \" + response.code());\r\n                            executeWithRetry(call, callback, retryCount + 1);\r\n                        } else {\r\n                            callback.onFailure(\"Ошибка сервера: \" + response.code() + \r\n                                    (errorBody != null && !errorBody.isEmpty() ? \" - \" + errorBody : \"\"));\r\n                        }\r\n                    } catch (IOException e) {\r\n                        Log.e(TAG, \"Ошибка при чтении errorBody\", e);\r\n                        \r\n                        if (retryCount < MAX_RETRY_ATTEMPTS) {\r\n                            // Повторяем попытку при ошибке чтения errorBody\r\n                            Log.d(TAG, \"Повторная попытка #\" + (retryCount + 1) + \" после ошибки чтения errorBody\");\r\n                            executeWithRetry(call, callback, retryCount + 1);\r\n                        } else {\r\n                            callback.onFailure(\"Ошибка сервера: \" + response.code());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            @Override\r\n            public void onFailure(Call<ResponseBody> call, Throwable t) {\r\n                Log.e(TAG, \"Ошибка сети\", t);\r\n                \r\n                if (retryCount < MAX_RETRY_ATTEMPTS) {\r\n                    // Делаем небольшую паузу перед повторной попыткой\r\n                    try {\r\n                        Thread.sleep(1000 * (retryCount + 1)); // Увеличиваем время ожидания с каждой попыткой\r\n                    } catch (InterruptedException e) {\r\n                        Log.e(TAG, \"Прерывание потока при ожидании повторной попытки\", e);\r\n                    }\r\n                    \r\n                    // Повторяем попытку при сетевой ошибке\r\n                    Log.d(TAG, \"Повторная попытка #\" + (retryCount + 1) + \" после сетевой ошибки: \" + t.getMessage());\r\n                    executeWithRetry(call, callback, retryCount + 1);\r\n                } else {\r\n                    callback.onFailure(\"Ошибка сети после \" + MAX_RETRY_ATTEMPTS + \" попыток: \" + t.getMessage());\r\n                }\r\n            }\r\n        });\r\n    }\r\n} 
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/network/services/RecipeManager.java b/app/src/main/java/com/example/cooking/network/services/RecipeManager.java
--- a/app/src/main/java/com/example/cooking/network/services/RecipeManager.java	(revision 13d31353b547022b462dac88d1070f6fc5bae46e)
+++ b/app/src/main/java/com/example/cooking/network/services/RecipeManager.java	(date 1745092808148)
@@ -198,75 +198,38 @@
                         Log.d(TAG, "Ответ сервера: " + responseStr);
                         
                         if (responseStr.isEmpty()) {
-                            Log.e(TAG, "Получен пустой ответ от сервера");
-                            if (retryCount < MAX_RETRY_ATTEMPTS) {
-                                // Повторяем попытку при пустом ответе
-                                Log.d(TAG, "Повторная попытка #" + (retryCount + 1));
-                                executeWithRetry(call, callback, retryCount + 1);
-                            } else {
-                                callback.onFailure("Ошибка сервера: пустой ответ после " + MAX_RETRY_ATTEMPTS + " попыток");
-                            }
-                            return;
-                        }
-                        
-                        // Парсим JSON
-                        JSONObject jsonResponse = new JSONObject(responseStr);
-                        boolean success = jsonResponse.optBoolean("success", false);
-                        String message = jsonResponse.optString("message", "");
-                        
-                        if (success) {
-                            // Очищаем кэш рецептов, чтобы при следующем запросе получить свежие данные
-                            RecipeRepository repository = new RecipeRepository(context);
-                            repository.clearCache();
-                            
-                            // Возвращаем успех
-                            callback.onSuccess(message.isEmpty() ? "Рецепт успешно сохранен" : message);
-                        } else {
-                            // Возвращаем ошибку
-                            callback.onFailure(message.isEmpty() ? "Ошибка при сохранении рецепта" : message);
-                        }
-                    } catch (IOException | JSONException e) {
-                        Log.e(TAG, "Ошибка при обработке ответа", e);
-                        
-                        if (retryCount < MAX_RETRY_ATTEMPTS) {
-                            // Повторяем попытку при ошибке обработки ответа
-                            Log.d(TAG, "Повторная попытка #" + (retryCount + 1) + " после ошибки обработки ответа");
-                            executeWithRetry(call, callback, retryCount + 1);
+                            callback.onSuccess("Рецепт успешно сохранён");
                         } else {
-                            callback.onFailure("Ошибка при обработке ответа: " + e.getMessage());
+                            callback.onSuccess(responseStr);
                         }
+                    } catch (IOException e) {
+                        Log.e(TAG, "Ошибка чтения ответа", e);
+                        callback.onFailure("Ошибка чтения ответа: " + e.getMessage());
                     }
                 } else {
+                    String errorBody = null;
                     try {
-                        // Пытаемся получить сообщение об ошибке
-                        String errorBody = response.errorBody() != null ? response.errorBody().string() : null;
-                        Log.e(TAG, "Ошибка HTTP " + response.code() + ": " + errorBody);
-                        
-                        // Специальная обработка для кода 403 (Forbidden)
-                        if (response.code() == 403) {
-                            callback.onFailure("У вас нет прав на редактирование этого рецепта. Только автор рецепта или администратор могут вносить изменения.");
-                            return;
-                        }
-                        
-                        // Проверяем, можно ли повторить запрос
-                        if (retryCount < MAX_RETRY_ATTEMPTS && (response.code() >= 500 || response.code() == 429)) {
-                            // Повторяем попытку при серверных ошибках (5xx) или слишком частых запросах (429)
-                            Log.d(TAG, "Повторная попытка #" + (retryCount + 1) + " после HTTP ошибки " + response.code());
-                            executeWithRetry(call, callback, retryCount + 1);
-                        } else {
-                            callback.onFailure("Ошибка сервера: " + response.code() + 
-                                    (errorBody != null && !errorBody.isEmpty() ? " - " + errorBody : ""));
-                        }
+                        errorBody = response.errorBody() != null ? response.errorBody().string() : null;
                     } catch (IOException e) {
-                        Log.e(TAG, "Ошибка при чтении errorBody", e);
-                        
-                        if (retryCount < MAX_RETRY_ATTEMPTS) {
-                            // Повторяем попытку при ошибке чтения errorBody
-                            Log.d(TAG, "Повторная попытка #" + (retryCount + 1) + " после ошибки чтения errorBody");
-                            executeWithRetry(call, callback, retryCount + 1);
-                        } else {
-                            callback.onFailure("Ошибка сервера: " + response.code());
-                        }
+                        Log.e(TAG, "Ошибка чтения errorBody", e);
+                    }
+                    String errorMsg = "Ошибка HTTP " + response.code();
+                    if (errorBody != null && !errorBody.isEmpty()) {
+                        errorMsg += ": " + errorBody;
+                    }
+                    // Обработка дублирующей ошибки как успешной
+                    if (errorBody != null && (errorBody.contains("уже существует") || errorBody.contains("duplicate") || errorBody.contains("already exists") || errorBody.contains("дублирующий"))) {
+                        Log.w(TAG, "Дублирующий запрос: " + errorBody);
+                        callback.onSuccess("Рецепт уже существует или был добавлен ранее");
+                        return;
+                    }
+                    Log.e(TAG, errorMsg);
+                    // Повторяем попытку, если не превышен лимит
+                    if (retryCount < MAX_RETRY_ATTEMPTS) {
+                        Log.d(TAG, "Повторная попытка запроса: " + (retryCount + 1));
+                        executeWithRetry(call, callback, retryCount + 1);
+                    } else {
+                        callback.onFailure(errorMsg);
                     }
                 }
             }
@@ -292,4 +255,4 @@
             }
         });
     }
-} 
\ No newline at end of file
+}
\ No newline at end of file
Index: app/src/main/java/com/example/cooking/data/repositories/RecipeLocalRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.data.repositories;\r\n\r\nimport android.content.Context;\r\nimport android.util.Log;\r\n\r\nimport androidx.lifecycle.LiveData;\r\nimport androidx.lifecycle.Transformations;\r\n\r\nimport com.example.cooking.Recipe.Recipe;\r\nimport com.example.cooking.data.database.AppDatabase;\r\nimport com.example.cooking.data.database.RecipeDao;\r\nimport com.example.cooking.data.database.RecipeEntity;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\n/**\r\n * Репозиторий для работы с локальной базой данных рецептов\r\n */\r\npublic class RecipeLocalRepository {\r\n    \r\n    private static final String TAG = \"RecipeLocalRepository\";\r\n    private final RecipeDao recipeDao;\r\n    private final ExecutorService executor;\r\n    \r\n    public RecipeLocalRepository(Context context) {\r\n        AppDatabase database = AppDatabase.getInstance(context);\r\n        recipeDao = database.recipeDao();\r\n        executor = Executors.newSingleThreadExecutor();\r\n    }\r\n    \r\n    /**\r\n     * Получить все рецепты из базы данных\r\n     * @return LiveData список рецептов\r\n     */\r\n    public LiveData<List<Recipe>> getAllRecipes() {\r\n        // Трансформация List<RecipeEntity> в List<Recipe>\r\n        return Transformations.map(\r\n            recipeDao.getAllRecipes(),\r\n            entities -> {\r\n                List<Recipe> recipes = new ArrayList<>();\r\n                for (RecipeEntity entity : entities) {\r\n                    recipes.add(entity.toRecipe());\r\n                }\r\n                return recipes;\r\n            }\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Вставить список рецептов в базу данных\r\n     * @param recipes список рецептов\r\n     */\r\n    public void insertAll(List<Recipe> recipes) {\r\n        List<RecipeEntity> entities = new ArrayList<>();\r\n        for (Recipe recipe : recipes) {\r\n            entities.add(new RecipeEntity(recipe));\r\n        }\r\n        recipeDao.insertAll(entities);\r\n    }\r\n    \r\n    /**\r\n     * Обновить рецепт в базе данных\r\n     * @param recipe рецепт для обновления\r\n     */\r\n    public void update(Recipe recipe) {\r\n        executor.execute(() -> recipeDao.update(new RecipeEntity(recipe)));\r\n    }\r\n    \r\n    /**\r\n     * Обновить состояние лайка рецепта\r\n     * @param recipeId идентификатор рецепта\r\n     * @param isLiked новое состояние лайка\r\n     */\r\n    public void updateLikeStatus(int recipeId, boolean isLiked) {\r\n        try {\r\n            recipeDao.updateLikeStatus(recipeId, isLiked);\r\n            Log.d(TAG, \"Статус лайка обновлен в локальной базе: recipeId=\" + recipeId + \", isLiked=\" + isLiked);\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка обновления статуса лайка: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Получить лайкнутые рецепты\r\n     * @return LiveData список лайкнутых рецептов\r\n     */\r\n    public LiveData<List<Recipe>> getLikedRecipes() {\r\n        return Transformations.map(\r\n            recipeDao.getLikedRecipes(),\r\n            entities -> {\r\n                List<Recipe> recipes = new ArrayList<>();\r\n                for (RecipeEntity entity : entities) {\r\n                    recipes.add(entity.toRecipe());\r\n                }\r\n                return recipes;\r\n            }\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Синхронно получить рецепт по идентификатору\r\n     * @param id идентификатор рецепта\r\n     * @return рецепт или null, если не найден\r\n     */\r\n    public Recipe getRecipeById(int id) {\r\n        RecipeEntity entity = recipeDao.getRecipeById(id);\r\n        return entity != null ? entity.toRecipe() : null;\r\n    }\r\n    \r\n    /**\r\n     * Очистить все рецепты из базы данных\r\n     */\r\n    public void clearAll() {\r\n        executor.execute(recipeDao::deleteAll);\r\n    }\r\n    \r\n    /**\r\n     * Очистить все рецепты из базы данных синхронно (для использования в транзакциях)\r\n     */\r\n    public void clearAllSync() {\r\n        try {\r\n            recipeDao.deleteAll();\r\n            Log.d(TAG, \"База данных рецептов очищена синхронно\");\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка при очистке базы данных синхронно\", e);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Удалить рецепт из базы данных по идентификатору\r\n     * @param recipeId идентификатор рецепта для удаления\r\n     */\r\n    public void deleteRecipe(int recipeId) {\r\n        try {\r\n            executor.execute(() -> {\r\n                try {\r\n                    RecipeEntity recipe = recipeDao.getRecipeById(recipeId);\r\n                    if (recipe != null) {\r\n                        recipeDao.delete(recipe);\r\n                        Log.d(TAG, \"Рецепт успешно удален из базы данных: \" + recipeId);\r\n                    } else {\r\n                        Log.w(TAG, \"Попытка удалить несуществующий рецепт: \" + recipeId);\r\n                    }\r\n                } catch (Exception e) {\r\n                    Log.e(TAG, \"Ошибка при удалении рецепта: \" + recipeId, e);\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка при запуске задачи удаления рецепта: \" + recipeId, e);\r\n        }\r\n    }\r\n} 
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/data/repositories/RecipeLocalRepository.java b/app/src/main/java/com/example/cooking/data/repositories/RecipeLocalRepository.java
--- a/app/src/main/java/com/example/cooking/data/repositories/RecipeLocalRepository.java	(revision 13d31353b547022b462dac88d1070f6fc5bae46e)
+++ b/app/src/main/java/com/example/cooking/data/repositories/RecipeLocalRepository.java	(date 1745092749981)
@@ -100,6 +100,19 @@
         );
     }
     
+    /**
+     * Синхронно получить все рецепты из базы данных
+     * @return список рецептов
+     */
+    public List<Recipe> getAllRecipesList() {
+        List<RecipeEntity> entities = recipeDao.getAllRecipesList();
+        List<Recipe> recipes = new ArrayList<>();
+        for (RecipeEntity entity : entities) {
+            recipes.add(entity.toRecipe());
+        }
+        return recipes;
+    }
+    
     /**
      * Синхронно получить рецепт по идентификатору
      * @param id идентификатор рецепта
@@ -152,4 +165,4 @@
             Log.e(TAG, "Ошибка при запуске задачи удаления рецепта: " + recipeId, e);
         }
     }
-} 
\ No newline at end of file
+}
\ No newline at end of file
Index: app/src/main/java/com/example/cooking/ui/viewmodels/AddRecipeViewModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.ui.viewmodels;\r\n\r\nimport android.app.Application;\r\nimport android.content.Context;\r\nimport android.graphics.Bitmap;\r\nimport android.net.ConnectivityManager;\r\nimport android.net.NetworkInfo;\r\nimport android.net.Uri;\r\nimport android.util.Log;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.lifecycle.AndroidViewModel;\r\nimport androidx.lifecycle.LiveData;\r\nimport androidx.lifecycle.MutableLiveData;\r\n\r\nimport com.example.cooking.Recipe.Ingredient;\r\nimport com.example.cooking.Recipe.Step;\r\nimport com.example.cooking.network.services.RecipeManager;\r\nimport com.example.cooking.utils.MySharedPreferences;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.InputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * ViewModel для экрана добавления рецепта\r\n * Управляет бизнес-логикой создания нового рецепта\r\n */\r\npublic class AddRecipeViewModel extends AndroidViewModel {\r\n    private static final String TAG = \"AddRecipeViewModel\";\r\n    \r\n    // LiveData для UI состояний\r\n    private final MutableLiveData<Boolean> isLoading = new MutableLiveData<>(false);\r\n    private final MutableLiveData<String> errorMessage = new MutableLiveData<>();\r\n    private final MutableLiveData<Boolean> saveSuccess = new MutableLiveData<>(false);\r\n    \r\n    // LiveData для валидации полей\r\n    private final MutableLiveData<String> titleError = new MutableLiveData<>();\r\n    private final MutableLiveData<String> ingredientsListError = new MutableLiveData<>();\r\n    private final MutableLiveData<String> stepsListError = new MutableLiveData<>();\r\n    private final MutableLiveData<String> imageError = new MutableLiveData<>();\r\n    \r\n    // Данные рецепта\r\n    private final MutableLiveData<String> title = new MutableLiveData<>(\"\");\r\n    private final MutableLiveData<List<Ingredient>> ingredients = new MutableLiveData<>(new ArrayList<>());\r\n    private final MutableLiveData<List<Step>> steps = new MutableLiveData<>(new ArrayList<>());\r\n    private byte[] imageBytes = null;\r\n    \r\n    // Сервисы\r\n    private final RecipeManager recipeManager;\r\n    private final MySharedPreferences preferences;\r\n    \r\n    public AddRecipeViewModel(@NonNull Application application) {\r\n        super(application);\r\n        preferences = new MySharedPreferences(application);\r\n        recipeManager = new RecipeManager(application);\r\n        \r\n        // Инициализируем списки с одним пустым элементом\r\n        ArrayList<Ingredient> initialIngredients = new ArrayList<>();\r\n        initialIngredients.add(new Ingredient());\r\n        ingredients.setValue(initialIngredients);\r\n        \r\n        ArrayList<Step> initialSteps = new ArrayList<>();\r\n        Step initialStep = new Step();\r\n        initialStep.setNumber(1);\r\n        initialSteps.add(initialStep);\r\n        steps.setValue(initialSteps);\r\n    }\r\n    \r\n    /**\r\n     * Сохраняет новый рецепт\r\n     */\r\n    public void saveRecipe() {\r\n        // Проверяем подключение к интернету\r\n        if (!isNetworkAvailable()) {\r\n            errorMessage.setValue(\"Отсутствует подключение к интернету\");\r\n            return;\r\n        }\r\n        \r\n        // Проверяем валидность всех полей\r\n        if (!validateAll()) {\r\n            return;\r\n        }\r\n        \r\n        // Показываем индикатор загрузки\r\n        isLoading.setValue(true);\r\n        \r\n        // Получаем ID пользователя\r\n        String userId = preferences.getString(\"userId\", \"99\");\r\n        \r\n        // Получаем текущие данные из LiveData\r\n        String currentTitle = title.getValue() != null ? title.getValue() : \"\";\r\n        List<Ingredient> currentIngredients = ingredients.getValue();\r\n        List<Step> currentSteps = steps.getValue();\r\n        \r\n        // Убедимся, что списки не null (хотя инициализированы)\r\n        if (currentIngredients == null) currentIngredients = new ArrayList<>();\r\n        if (currentSteps == null) currentSteps = new ArrayList<>();\r\n\r\n        // Log.d(TAG, \"Сохранение рецепта: title=\" + currentTitle + \", userId=\" + userId + \", ingredients=\" + ingredientsString + \", steps=\" + stepsString);\r\n        Log.d(TAG, \"Сохранение рецепта: title=\" + currentTitle + \", userId=\" + userId + \", ingredients count=\" + currentIngredients.size() + \", steps count=\" + currentSteps.size());\r\n        \r\n        recipeManager.saveRecipe(\r\n            currentTitle,\r\n            currentIngredients, // Передаем список напрямую\r\n            currentSteps, // Передаем список напрямую\r\n            userId,\r\n            null, // recipeId - предполагаем, что это всегда новый рецепт в AddRecipeActivity\r\n            imageBytes,\r\n            new RecipeManager.RecipeSaveCallback() {\r\n                @Override\r\n                public void onSuccess(String message) {\r\n                    isLoading.postValue(false);\r\n                    saveSuccess.postValue(true);\r\n                    Log.d(TAG, \"Рецепт успешно сохранен: \" + message);\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(String error) {\r\n                    isLoading.postValue(false);\r\n                    errorMessage.postValue(error);\r\n                    Log.e(TAG, \"Ошибка при сохранении рецепта: \" + error);\r\n                }\r\n            }\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Устанавливает название рецепта\r\n     */\r\n    public void setTitle(String title) {\r\n        this.title.setValue(title);\r\n        validateTitle();\r\n    }\r\n    \r\n    /**\r\n     * Добавляет пустой ингредиент в список\r\n     */\r\n    public void addEmptyIngredient() {\r\n        List<Ingredient> currentList = ingredients.getValue();\r\n        if (currentList == null) {\r\n            currentList = new ArrayList<>();\r\n        }\r\n        currentList.add(new Ingredient());\r\n        ingredients.setValue(currentList);\r\n        // Убираем валидацию при добавлении нового пустого ингредиента\r\n        // validateIngredientsList();\r\n    }\r\n    \r\n    /**\r\n     * Обновляет ингредиент по позиции\r\n     */\r\n    public void updateIngredient(int position, Ingredient ingredient) {\r\n        List<Ingredient> currentList = ingredients.getValue();\r\n        if (currentList != null && position >= 0 && position < currentList.size()) {\r\n            currentList.set(position, ingredient);\r\n            ingredients.setValue(currentList);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Удаляет ингредиент по позиции\r\n     */\r\n    public void removeIngredient(int position) {\r\n        List<Ingredient> currentList = ingredients.getValue();\r\n        // Не удаляем, если это последний ингредиент\r\n        if (currentList != null && currentList.size() > 1 && position >= 0 && position < currentList.size()) {\r\n            currentList.remove(position);\r\n            ingredients.setValue(currentList);\r\n            validateIngredientsList();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Добавляет пустой шаг в список\r\n     */\r\n    public void addEmptyStep() {\r\n        List<Step> currentList = steps.getValue();\r\n        if (currentList == null) {\r\n            currentList = new ArrayList<>();\r\n        }\r\n        Step newStep = new Step();\r\n        newStep.setNumber(currentList.size() + 1);\r\n        currentList.add(newStep);\r\n        steps.setValue(currentList);\r\n        // Убираем валидацию при добавлении нового пустого шага\r\n        // validateStepsList();\r\n    }\r\n    \r\n    /**\r\n     * Обновляет шаг по позиции\r\n     */\r\n    public void updateStep(int position, Step step) {\r\n        List<Step> currentList = steps.getValue();\r\n        if (currentList != null && position >= 0 && position < currentList.size()) {\r\n            currentList.set(position, step);\r\n            steps.setValue(currentList);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Удаляет шаг по позиции и обновляет нумерацию\r\n     */\r\n    public void removeStep(int position) {\r\n        List<Step> currentList = steps.getValue();\r\n        // Не удаляем, если это последний шаг\r\n        if (currentList != null && currentList.size() > 1 && position >= 0 && position < currentList.size()) {\r\n            currentList.remove(position);\r\n            for (int i = 0; i < currentList.size(); i++) {\r\n                currentList.get(i).setNumber(i + 1);\r\n            }\r\n            steps.setValue(currentList);\r\n            validateStepsList();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Обрабатывает выбранное изображение и преобразует его в массив байтов\r\n     */\r\n    public void processSelectedImage(Uri imageUri) {\r\n        try {\r\n            InputStream inputStream = getApplication().getContentResolver().openInputStream(imageUri);\r\n            Bitmap bitmap = android.graphics.BitmapFactory.decodeStream(inputStream);\r\n            \r\n            // Сжимаем изображение до разумного размера\r\n            Bitmap resizedBitmap = resizeBitmap(bitmap, 800);\r\n            \r\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n            resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 80, byteArrayOutputStream);\r\n            imageBytes = byteArrayOutputStream.toByteArray();\r\n            \r\n            if (inputStream != null) {\r\n                inputStream.close();\r\n            }\r\n            \r\n            Log.d(TAG, \"Изображение обработано, размер: \" + imageBytes.length + \" байт\");\r\n            \r\n            // Очищаем ошибку изображения, если она была\r\n            imageError.setValue(null);\r\n            validateImage();\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка при обработке изображения\", e);\r\n            imageError.setValue(\"Ошибка при обработке изображения: \" + e.getMessage());\r\n            imageBytes = null;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Изменяет размер Bitmap до указанного максимального значения\r\n     */\r\n    private Bitmap resizeBitmap(Bitmap bitmap, int maxSide) {\r\n        int width = bitmap.getWidth();\r\n        int height = bitmap.getHeight();\r\n        \r\n        if (width <= maxSide && height <= maxSide) {\r\n            return bitmap; // Нет необходимости менять размер\r\n        }\r\n        \r\n        float ratio = (float) width / height;\r\n        int newWidth, newHeight;\r\n        \r\n        if (width > height) {\r\n            newWidth = maxSide;\r\n            newHeight = (int) (maxSide / ratio);\r\n        } else {\r\n            newHeight = maxSide;\r\n            newWidth = (int) (maxSide * ratio);\r\n        }\r\n        \r\n        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true);\r\n    }\r\n    \r\n    /**\r\n     * Проверяет все поля на валидность\r\n     */\r\n    private boolean validateAll() {\r\n        titleError.setValue(null);\r\n        ingredientsListError.setValue(null);\r\n        stepsListError.setValue(null);\r\n        imageError.setValue(null);\r\n        \r\n        boolean isValid = true;\r\n        \r\n        // Проверяем название\r\n        if (!validateTitle()) {\r\n            isValid = false;\r\n        }\r\n        \r\n        // Проверяем ингредиенты\r\n        if (!validateIngredientsList()) {\r\n            isValid = false;\r\n        }\r\n        \r\n        // Проверяем шаги\r\n        if (!validateStepsList()) {\r\n            isValid = false;\r\n        }\r\n        \r\n        // Проверяем изображение\r\n        if (!validateImage()) {\r\n            isValid = false;\r\n        }\r\n        \r\n        return isValid;\r\n    }\r\n    \r\n    /**\r\n     * Проверяет валидность названия рецепта\r\n     */\r\n    private boolean validateTitle() {\r\n        String currentTitle = title.getValue();\r\n        if (currentTitle == null || currentTitle.trim().isEmpty()) {\r\n            titleError.setValue(\"Название рецепта не может быть пустым\");\r\n            return false;\r\n        } else if (currentTitle.trim().length() < 3) {\r\n            titleError.setValue(\"Название должно содержать минимум 3 символа\");\r\n            return false;\r\n        } else if (currentTitle.length() > 100) {\r\n            titleError.setValue(\"Название не должно превышать 100 символов\");\r\n            return false;\r\n        } else {\r\n            titleError.setValue(null);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Проверяет валидность списка ингредиентов\r\n     */\r\n    private boolean validateIngredientsList() {\r\n        List<Ingredient> currentList = ingredients.getValue();\r\n        if (currentList == null || currentList.isEmpty()) {\r\n            ingredientsListError.setValue(\"Добавьте хотя бы один ингредиент\");\r\n            Log.d(TAG, \"validateIngredientsList: Список ингредиентов пуст\");\r\n            return false;\r\n        }\r\n        \r\n        boolean allValid = true;\r\n        for (int i = 0; i < currentList.size(); i++) {\r\n            Ingredient ingredient = currentList.get(i);\r\n            String name = ingredient.getName();\r\n            String type = ingredient.getType();\r\n            int count = ingredient.getCount();\r\n            \r\n            Log.d(TAG, \"validateIngredientsList: Проверка ингредиента #\" + i + \r\n                    \": name='\" + name + \"', type='\" + type + \"', count=\" + count);\r\n            \r\n            // Проверяем наличие значений\r\n            if ((name == null || name.trim().isEmpty()) ||\r\n                (type == null || type.trim().isEmpty()) ||\r\n                count <= 0) {\r\n                \r\n                Log.d(TAG, \"validateIngredientsList: Ингредиент #\" + i + \" не прошел валидацию\");\r\n                \r\n                // Вместо немедленного возврата, отмечаем, что есть невалидный ингредиент\r\n                allValid = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (!allValid) {\r\n            ingredientsListError.setValue(\"Заполните все поля для каждого ингредиента (название, количество > 0, тип)\");\r\n            return false;\r\n        }\r\n        \r\n        // Все ингредиенты валидны\r\n        Log.d(TAG, \"validateIngredientsList: Все ингредиенты прошли валидацию\");\r\n        ingredientsListError.setValue(null);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Проверяет валидность списка шагов\r\n     */\r\n    private boolean validateStepsList() {\r\n        List<Step> currentList = steps.getValue();\r\n        if (currentList == null || currentList.isEmpty()) {\r\n            stepsListError.setValue(\"Добавьте хотя бы один шаг приготовления\");\r\n            return false;\r\n        }\r\n        for (Step step : currentList) {\r\n            if (step.getInstruction() == null || step.getInstruction().trim().isEmpty()) {\r\n                stepsListError.setValue(\"Заполните описание для каждого шага\");\r\n                return false;\r\n            }\r\n        }\r\n        stepsListError.setValue(null);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Проверяет, выбрано ли изображение\r\n     */\r\n    private boolean validateImage() {\r\n        if (imageBytes == null) {\r\n            imageError.setValue(\"Выберите изображение для рецепта\");\r\n            return false;\r\n        } else {\r\n            imageError.setValue(null);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Проверяет подключение к интернету\r\n     */\r\n    private boolean isNetworkAvailable() {\r\n        ConnectivityManager connectivityManager = (ConnectivityManager) \r\n                getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();\r\n        return activeNetworkInfo != null && activeNetworkInfo.isConnected();\r\n    }\r\n    \r\n    // Геттеры для LiveData\r\n    public LiveData<Boolean> getIsLoading() {\r\n        return isLoading;\r\n    }\r\n    \r\n    public LiveData<String> getErrorMessage() {\r\n        return errorMessage;\r\n    }\r\n    \r\n    public LiveData<Boolean> getSaveSuccess() {\r\n        return saveSuccess;\r\n    }\r\n    \r\n    public LiveData<String> getTitleError() {\r\n        return titleError;\r\n    }\r\n    \r\n    public LiveData<String> getIngredientsListError() {\r\n        return ingredientsListError;\r\n    }\r\n    \r\n    public LiveData<String> getStepsListError() {\r\n        return stepsListError;\r\n    }\r\n    \r\n    public LiveData<String> getImageError() {\r\n        return imageError;\r\n    }\r\n    \r\n    public LiveData<List<Ingredient>> getIngredients() {\r\n        return ingredients;\r\n    }\r\n    \r\n    public LiveData<List<Step>> getSteps() {\r\n        return steps;\r\n    }\r\n    \r\n    public LiveData<String> getTitle() {\r\n        return title;\r\n    }\r\n\r\n    /**\r\n     * Возвращает true, если изображение было выбрано и обработано.\r\n     */\r\n    public boolean hasImage() {\r\n        return imageBytes != null && imageBytes.length > 0;\r\n    }\r\n} 
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/ui/viewmodels/AddRecipeViewModel.java b/app/src/main/java/com/example/cooking/ui/viewmodels/AddRecipeViewModel.java
--- a/app/src/main/java/com/example/cooking/ui/viewmodels/AddRecipeViewModel.java	(revision 13d31353b547022b462dac88d1070f6fc5bae46e)
+++ b/app/src/main/java/com/example/cooking/ui/viewmodels/AddRecipeViewModel.java	(date 1745093394816)
@@ -115,6 +115,19 @@
                     isLoading.postValue(false);
                     saveSuccess.postValue(true);
                     Log.d(TAG, "Рецепт успешно сохранен: " + message);
+                    // Сохраняем рецепт в локальную базу данных
+                    RecipeLocalRepository localRepository = new RecipeLocalRepository(getApplication());
+                    com.example.cooking.Recipe.Recipe localRecipe = new com.example.cooking.Recipe.Recipe(
+                        null, // id будет сгенерирован локально
+                        title.getValue(),
+                        ingredients.getValue(),
+                        steps.getValue(),
+                        null, // photo_url, если нужно, можно реализовать сохранение локального пути
+                        preferences.getString("userId", "99"),
+                        false, // isLiked по умолчанию
+                        imageBytes // если Recipe поддерживает хранение байтов изображения
+                    );
+                    localRepository.insertAll(java.util.Collections.singletonList(localRecipe));
                 }
 
                 @Override
@@ -460,4 +473,4 @@
     public boolean hasImage() {
         return imageBytes != null && imageBytes.length > 0;
     }
-} 
\ No newline at end of file
+}
\ No newline at end of file
