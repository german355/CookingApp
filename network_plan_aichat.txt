**План создания сетевого слоя для Ai Chat**

1.  **Стек технологий:**
    *   **HTTP Client:** Retrofit 2.9.0 (с OkHttp 4.12.0 под капотом)
    *   **JSON Serialization/Deserialization:** Gson 2.9.0
    *   **Асинхронность:** Retrofit Callbacks (для консистентности с существующим `ApiService`) или RxJava3 (если будет принято решение о постепенном переходе). Для данного плана будем ориентироваться на Retrofit Callbacks.
    *   **Аутентификация:** Используем существующий `AuthInterceptor` для автоматического добавления Firebase ID токена.

2.  **Архитектура:**
    *   **ApiService:** Интерфейс Retrofit будет расширен методами для взаимодействия с эндпоинтами Ai чата.
    *   **Data Transfer Objects (DTOs):** Классы для представления тел запросов и ответов.
    *   **Repository (опционально, но рекомендуется для лучшей структуры):** Класс, который будет инкапсулировать логику вызова `ApiService` и предоставлять данные ViewModel. Это поможет отделить логику работы с сетью от UI-слоя.
    *   **ViewModel:** Будет использовать Repository для получения данных и обновления UI.

3.  **Классы и их методы:**

    **3.1. `com.example.cooking.network.api.ApiService.java` (дополнения)**
    *   Будут добавлены новые методы для эндпоинтов Ai чата.

    ```java
    // ... существующие методы ...

    // =============== Ai Chat ===============

    /**
     * Начать новую сессию чата.
     * @return Call объект с ответом сервера (например, ChatSessionResponse или GeneralServerResponse)
     */
    @POST("chatbot/start-session")
    Call<ChatSessionResponse> startChatSession(); // Предположим, что сервер возвращает какой-то ID сессии или статус

    /**
     * Отправить сообщение в чат.
     * @param request тело запроса с сообщением
     * @return Call объект с ответом сервера (например, ChatMessageResponse или GeneralServerResponse)
     */
    @POST("chatbot/send-message")
    Call<ChatMessageResponse> sendChatMessage(@Body ChatMessageRequest request);

    /**
     * Получить историю сообщений чата.
     * @return Call объект с ответом сервера (например, ChatHistoryResponse)
     */
    @GET("chatbot/get-history")
    Call<ChatHistoryResponse> getChatHistory();
    ```

    **3.2. DTO классы (новые файлы в `com.example.cooking.network.models.chat` или аналогичной директории)**

    *   `com.example.cooking.network.models.chat.ChatMessageRequest.java`
        ```java
        package com.example.cooking.network.models.chat;

        import com.google.gson.annotations.SerializedName;

        public class ChatMessageRequest {
            @SerializedName("message")
            private String message;

            public ChatMessageRequest(String message) {
                this.message = message;
            }

            // Геттеры и сеттеры (или public поля, если соответствует стилю проекта)
            public String getMessage() {
                return message;
            }

            public void setMessage(String message) {
                this.message = message;
            }
        }
        ```

    *   `com.example.cooking.network.models.chat.ChatSessionResponse.java` (Пример, структура зависит от реального ответа сервера)
        ```java
        package com.example.cooking.network.models.chat;

        import com.google.gson.annotations.SerializedName;

        public class ChatSessionResponse {
            // Пример полей, которые может вернуть сервер
            @SerializedName("session_id")
            private String sessionId;

            @SerializedName("status")
            private String status;
            
            @SerializedName("message") // Для общих сообщений от сервера, например, "Session started"
            private String message;


            // Геттеры и сеттеры
            public String getSessionId() {
                return sessionId;
            }

            public void setSessionId(String sessionId) {
                this.sessionId = sessionId;
            }

            public String getStatus() {
                return status;
            }

            public void setStatus(String status) {
                this.status = status;
            }
            
            public String getMessage() {
                return message;
            }

            public void setMessage(String message) {
                this.message = message;
            }
        }
        ```
        *Если сервер возвращает простой статус успеха/неудачи без специфичных данных сессии, можно переиспользовать существующий `GeneralServerResponse`.*

    *   `com.example.cooking.network.models.chat.ChatMessageResponse.java` (Пример, структура зависит от реального ответа сервера)
        ```java
        package com.example.cooking.network.models.chat;

        import com.google.gson.annotations.SerializedName;

        // Этот класс может представлять как ответ на отправленное сообщение, 
        // так и одно сообщение в истории
        public class ChatMessage { 
            @SerializedName("id") // ID сообщения
            private String id;

            @SerializedName("text") // Текст сообщения
            private String text;

            @SerializedName("sender") // "user" или "bot"
            private String sender;

            @SerializedName("timestamp") // Временная метка
            private long timestamp;

            // Геттеры и сеттеры
            public String getId() { return id; }
            public void setId(String id) { this.id = id; }
            public String getText() { return text; }
            public void setText(String text) { this.text = text; }
            public String getSender() { return sender; }
            public void setSender(String sender) { this.sender = sender; }
            public long getTimestamp() { return timestamp; }
            public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
        }
        ```
        *Если ответ на `send-message` просто подтверждает доставку, можно использовать `GeneralServerResponse`. Если он возвращает само сообщение (например, с присвоенным ID и timestamp), то можно использовать `ChatMessage`.*


    *   `com.example.cooking.network.models.chat.ChatHistoryResponse.java` (Пример, структура зависит от реального ответа сервера)
        ```java
        package com.example.cooking.network.models.chat;

        import com.google.gson.annotations.SerializedName;
        import java.util.List;

        public class ChatHistoryResponse {
            @SerializedName("messages")
            private List<ChatMessage> messages; // Используем ChatMessage из предыдущего примера

            @SerializedName("has_more") // Для пагинации, если поддерживается
            private boolean hasMore;
            
            // Геттеры и сеттеры
            public List<ChatMessage> getMessages() {
                return messages;
            }

            public void setMessages(List<ChatMessage> messages) {
                this.messages = messages;
            }

            public boolean isHasMore() {
                return hasMore;
            }

            public void setHasMore(boolean hasMore) {
                this.hasMore = hasMore;
            }
        }
        ```

    **3.3. `com.example.cooking.data.repository.ChatRepository.java` (новый файл)**
    *   Этот класс будет использовать `ApiService` для выполнения сетевых запросов, связанных с чатом.
    *   Он будет предоставлять LiveData или другие наблюдаемые объекты для ViewModel.

    ```java
    package com.example.cooking.data.repository;

    import androidx.lifecycle.LiveData;
    import androidx.lifecycle.MutableLiveData;

    import com.example.cooking.network.ApiClient; // Предполагается, что у вас есть такой класс для получения ApiService
    import com.example.cooking.network.api.ApiService;
    import com.example.cooking.network.models.chat.ChatMessageRequest;
    import com.example.cooking.network.models.chat.ChatSessionResponse;
    import com.example.cooking.network.models.chat.ChatMessageResponse; // или ChatMessage, если sendChatMessage возвращает его
    import com.example.cooking.network.models.chat.ChatHistoryResponse;
    // import com.example.cooking.network.models.GeneralServerResponse; // Если используется

    import retrofit2.Call;
    import retrofit2.Callback;
    import retrofit2.Response;

    public class ChatRepository {
        private ApiService apiService;
        private static volatile ChatRepository instance;

        private ChatRepository() {
            apiService = ApiClient.getApiService(); // Получение экземпляра ApiService
        }

        public static ChatRepository getInstance() {
            if (instance == null) {
                synchronized (ChatRepository.class) {
                    if (instance == null) {
                        instance = new ChatRepository();
                    }
                }
            }
            return instance;
        }

        public LiveData<ChatSessionResponse> startChatSession() {
            MutableLiveData<ChatSessionResponse> data = new MutableLiveData<>();
            apiService.startChatSession().enqueue(new Callback<ChatSessionResponse>() {
                @Override
                public void onResponse(Call<ChatSessionResponse> call, Response<ChatSessionResponse> response) {
                    data.setValue(response.body());
                }

                @Override
                public void onFailure(Call<ChatSessionResponse> call, Throwable t) {
                    // Обработка ошибки, возможно, установить значение data с ошибкой
                    data.setValue(null); // Или специальный объект ошибки
                }
            });
            return data;
        }

        public LiveData<ChatMessageResponse> sendChatMessage(String message) {
            MutableLiveData<ChatMessageResponse> data = new MutableLiveData<>();
            ChatMessageRequest request = new ChatMessageRequest(message);
            apiService.sendChatMessage(request).enqueue(new Callback<ChatMessageResponse>() {
                @Override
                public void onResponse(Call<ChatMessageResponse> call, Response<ChatMessageResponse> response) {
                    data.setValue(response.body());
                }

                @Override
                public void onFailure(Call<ChatMessageResponse> call, Throwable t) {
                    data.setValue(null);
                }
            });
            return data;
        }

        public LiveData<ChatHistoryResponse> getChatHistory() {
            MutableLiveData<ChatHistoryResponse> data = new MutableLiveData<>();
            apiService.getChatHistory().enqueue(new Callback<ChatHistoryResponse>() {
                @Override
                public void onResponse(Call<ChatHistoryResponse> call, Response<ChatHistoryResponse> response) {
                    data.setValue(response.body());
                }

                @Override
                public void onFailure(Call<ChatHistoryResponse> call, Throwable t) {
                    data.setValue(null);
                }
            });
            return data;
        }
    }
    ```

    **3.4. `com.example.cooking.ui.viewmodels.ChatViewModel.java` (новый файл)**
    *   Этот ViewModel будет использовать `ChatRepository` для управления логикой чата и предоставления данных для UI (например, Fragment или Activity).

    ```java
    package com.example.cooking.ui.viewmodels;

    import androidx.lifecycle.LiveData;
    import androidx.lifecycle.ViewModel;
    import com.example.cooking.data.repository.ChatRepository;
    import com.example.cooking.network.models.chat.ChatSessionResponse;
    import com.example.cooking.network.models.chat.ChatMessageResponse;
    import com.example.cooking.network.models.chat.ChatHistoryResponse;

    public class ChatViewModel extends ViewModel {
        private ChatRepository chatRepository;
        
        public LiveData<ChatSessionResponse> sessionResponseLiveData;
        public LiveData<ChatMessageResponse> messageResponseLiveData;
        public LiveData<ChatHistoryResponse> historyResponseLiveData;

        public ChatViewModel() {
            chatRepository = ChatRepository.getInstance();
            // Инициализация LiveData может быть здесь или при первом запросе
        }

        public void startNewChatSession() {
            sessionResponseLiveData = chatRepository.startChatSession();
        }

        public void sendMessage(String message) {
            messageResponseLiveData = chatRepository.sendChatMessage(message);
        }

        public void loadChatHistory() {
            historyResponseLiveData = chatRepository.loadChatHistory();
        }
    }
    ```

4.  **Конфигурация Retrofit (`ApiClient.java` или аналогичный)**
    *   Убедиться, что `BASE_URL` в конфигурации Retrofit (обычно в классе типа `ApiClient` или `RetrofitClient`) соответствует базовому URL вашего API. Эндпоинты чата (`/chatbot/...`) будут добавлены к этому `BASE_URL`.
    *   Убедиться, что `AuthInterceptor` добавлен в OkHttpClient, используемый Retrofit. Судя по наличию файла, это уже должно быть сделано.
